{"ast":null,"code":"var _typeof = require(\"@babel/runtime/helpers/typeof\");\n\n/*!\nCopyright © 2016 Max Franz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the “Software”), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n(function (f) {\n  if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.weaver = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof require == \"function\" && require;\n\n    for (var o = 0; o < r.length; o++) {\n      s(r[o]);\n    }\n\n    return s;\n  }({\n    1: [function (_dereq_, module, exports) {\n      'use strict';\n\n      var is = _dereq_('./is');\n\n      var util = _dereq_('./util');\n\n      var Promise = _dereq_('./promise');\n\n      var Event = _dereq_('./event');\n\n      var define = {\n        // event function reusable stuff\n        event: {\n          regex: /(\\w+)(\\.\\w+)?/,\n          // regex for matching event strings (e.g. \"click.namespace\")\n          optionalTypeRegex: /(\\w+)?(\\.\\w+)?/,\n          falseCallback: function falseCallback() {\n            return false;\n          }\n        },\n        // event binding\n        on: function on(params) {\n          var defaults = {\n            unbindSelfOnTrigger: false,\n            unbindAllBindersOnTrigger: false\n          };\n          params = util.extend({}, defaults, params);\n          return function onImpl(events, data, callback) {\n            var self = this;\n            var selfIsArrayLike = self.length !== undefined;\n            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n            var eventsIsString = is.string(events);\n            var p = params;\n\n            if (is.fn(data) || data === false) {\n              // data is actually callback\n              callback = data;\n              data = undefined;\n            } // if there isn't a callback, we can't really do anything\n            // (can't speak for mapped events arg version)\n\n\n            if (!(is.fn(callback) || callback === false) && eventsIsString) {\n              return self; // maintain chaining\n            }\n\n            if (eventsIsString) {\n              // then convert to map\n              var map = {};\n              map[events] = callback;\n              events = map;\n            }\n\n            for (var evts in events) {\n              callback = events[evts];\n\n              if (callback === false) {\n                callback = define.event.falseCallback;\n              }\n\n              if (!is.fn(callback)) {\n                continue;\n              }\n\n              evts = evts.split(/\\s+/);\n\n              for (var i = 0; i < evts.length; i++) {\n                var evt = evts[i];\n\n                if (is.emptyString(evt)) {\n                  continue;\n                }\n\n                var match = evt.match(define.event.regex); // type[.namespace]\n\n                if (match) {\n                  var type = match[1];\n                  var namespace = match[2] ? match[2] : undefined;\n                  var listener = {\n                    callback: callback,\n                    // callback to run\n                    data: data,\n                    // extra data in eventObj.data\n                    type: type,\n                    // the event type (e.g. 'click')\n                    namespace: namespace,\n                    // the event namespace (e.g. \".foo\")\n                    unbindSelfOnTrigger: p.unbindSelfOnTrigger,\n                    unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,\n                    binders: all // who bound together\n\n                  };\n\n                  for (var j = 0; j < all.length; j++) {\n                    var _p = all[j]._private;\n                    _p.listeners = _p.listeners || [];\n\n                    _p.listeners.push(listener);\n                  }\n                }\n              } // for events array\n\n            } // for events map\n\n\n            return self; // maintain chaining\n          }; // function\n        },\n        // on\n        eventAliasesOn: function eventAliasesOn(proto) {\n          var p = proto;\n          p.addListener = p.listen = p.bind = p.on;\n          p.removeListener = p.unlisten = p.unbind = p.off;\n          p.emit = p.trigger; // this is just a wrapper alias of .on()\n\n          p.pon = p.promiseOn = function (events, selector) {\n            var self = this;\n            var args = Array.prototype.slice.call(arguments, 0);\n            return new Promise(function (resolve, reject) {\n              var callback = function callback(e) {\n                self.off.apply(self, offArgs);\n                resolve(e);\n              };\n\n              var onArgs = args.concat([callback]);\n              var offArgs = onArgs.concat([]);\n              self.on.apply(self, onArgs);\n            });\n          };\n        },\n        off: function offImpl(params) {\n          var defaults = {};\n          params = util.extend({}, defaults, params);\n          return function (events, callback) {\n            var self = this;\n            var selfIsArrayLike = self.length !== undefined;\n            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n            var eventsIsString = is.string(events);\n\n            if (arguments.length === 0) {\n              // then unbind all\n              for (var i = 0; i < all.length; i++) {\n                all[i]._private.listeners = [];\n              }\n\n              return self; // maintain chaining\n            }\n\n            if (eventsIsString) {\n              // then convert to map\n              var map = {};\n              map[events] = callback;\n              events = map;\n            }\n\n            for (var evts in events) {\n              callback = events[evts];\n\n              if (callback === false) {\n                callback = define.event.falseCallback;\n              }\n\n              evts = evts.split(/\\s+/);\n\n              for (var h = 0; h < evts.length; h++) {\n                var evt = evts[h];\n\n                if (is.emptyString(evt)) {\n                  continue;\n                }\n\n                var match = evt.match(define.event.optionalTypeRegex); // [type][.namespace]\n\n                if (match) {\n                  var type = match[1] ? match[1] : undefined;\n                  var namespace = match[2] ? match[2] : undefined;\n\n                  for (var i = 0; i < all.length; i++) {\n                    //\n                    var listeners = all[i]._private.listeners = all[i]._private.listeners || [];\n\n                    for (var j = 0; j < listeners.length; j++) {\n                      var listener = listeners[j];\n                      var nsMatches = !namespace || namespace === listener.namespace;\n                      var typeMatches = !type || listener.type === type;\n                      var cbMatches = !callback || callback === listener.callback;\n                      var listenerMatches = nsMatches && typeMatches && cbMatches; // delete listener if it matches\n\n                      if (listenerMatches) {\n                        listeners.splice(j, 1);\n                        j--;\n                      }\n                    } // for listeners\n\n                  } // for all\n\n                } // if match\n\n              } // for events array\n\n            } // for events map\n\n\n            return self; // maintain chaining\n          }; // function\n        },\n        // off\n        trigger: function trigger(params) {\n          var defaults = {};\n          params = util.extend({}, defaults, params);\n          return function triggerImpl(events, extraParams, fnToTrigger) {\n            var self = this;\n            var selfIsArrayLike = self.length !== undefined;\n            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n            var eventsIsString = is.string(events);\n            var eventsIsObject = is.plainObject(events);\n            var eventsIsEvent = is.event(events);\n\n            if (eventsIsString) {\n              // then make a plain event object for each event name\n              var evts = events.split(/\\s+/);\n              events = [];\n\n              for (var i = 0; i < evts.length; i++) {\n                var evt = evts[i];\n\n                if (is.emptyString(evt)) {\n                  continue;\n                }\n\n                var match = evt.match(define.event.regex); // type[.namespace]\n\n                var type = match[1];\n                var namespace = match[2] ? match[2] : undefined;\n                events.push({\n                  type: type,\n                  namespace: namespace\n                });\n              }\n            } else if (eventsIsObject) {\n              // put in length 1 array\n              var eventArgObj = events;\n              events = [eventArgObj];\n            }\n\n            if (extraParams) {\n              if (!is.array(extraParams)) {\n                // make sure extra params are in an array if specified\n                extraParams = [extraParams];\n              }\n            } else {\n              // otherwise, we've got nothing\n              extraParams = [];\n            }\n\n            for (var i = 0; i < events.length; i++) {\n              // trigger each event in order\n              var evtObj = events[i];\n\n              for (var j = 0; j < all.length; j++) {\n                // for each\n                var triggerer = all[j];\n                var listeners = triggerer._private.listeners = triggerer._private.listeners || [];\n                var bubbleUp = false; // create the event for this element from the event object\n\n                var evt;\n\n                if (eventsIsEvent) {\n                  // then just get the object\n                  evt = evtObj;\n                } else {\n                  // then we have to make one\n                  evt = new Event(evtObj, {\n                    namespace: evtObj.namespace\n                  });\n                }\n\n                if (fnToTrigger) {\n                  // then override the listeners list with just the one we specified\n                  listeners = [{\n                    namespace: evt.namespace,\n                    type: evt.type,\n                    callback: fnToTrigger\n                  }];\n                }\n\n                for (var k = 0; k < listeners.length; k++) {\n                  // check each listener\n                  var lis = listeners[k];\n                  var nsMatches = !lis.namespace || lis.namespace === evt.namespace;\n                  var typeMatches = lis.type === evt.type;\n                  var targetMatches = true;\n                  var listenerMatches = nsMatches && typeMatches && targetMatches;\n\n                  if (listenerMatches) {\n                    // then trigger it\n                    var args = [evt];\n                    args = args.concat(extraParams); // add extra params to args list\n\n                    if (lis.data) {\n                      // add on data plugged into binding\n                      evt.data = lis.data;\n                    } else {\n                      // or clear it in case the event obj is reused\n                      evt.data = undefined;\n                    }\n\n                    if (lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger) {\n                      // then remove listener\n                      listeners.splice(k, 1);\n                      k--;\n                    }\n\n                    if (lis.unbindAllBindersOnTrigger) {\n                      // then delete the listener for all binders\n                      var binders = lis.binders;\n\n                      for (var l = 0; l < binders.length; l++) {\n                        var binder = binders[l];\n\n                        if (!binder || binder === triggerer) {\n                          continue;\n                        } // already handled triggerer or we can't handle it\n\n\n                        var binderListeners = binder._private.listeners;\n\n                        for (var m = 0; m < binderListeners.length; m++) {\n                          var binderListener = binderListeners[m];\n\n                          if (binderListener === lis) {\n                            // delete listener from list\n                            binderListeners.splice(m, 1);\n                            m--;\n                          }\n                        }\n                      }\n                    } // run the callback\n\n\n                    var context = triggerer;\n                    var ret = lis.callback.apply(context, args);\n\n                    if (ret === false || evt.isPropagationStopped()) {\n                      // then don't bubble\n                      bubbleUp = false;\n\n                      if (ret === false) {\n                        // returning false is a shorthand for stopping propagation and preventing the def. action\n                        evt.stopPropagation();\n                        evt.preventDefault();\n                      }\n                    }\n                  } // if listener matches\n\n                } // for each listener\n\n\n                if (bubbleUp) {// TODO if bubbling is supported...\n                }\n              } // for each of all\n\n            } // for each event\n\n\n            return self; // maintain chaining\n          }; // function\n        } // trigger\n\n      }; // define\n\n      module.exports = define;\n    }, {\n      \"./event\": 2,\n      \"./is\": 5,\n      \"./promise\": 6,\n      \"./util\": 8\n    }],\n    2: [function (_dereq_, module, exports) {\n      'use strict'; // https://github.com/jquery/jquery/blob/master/src/event.js\n\n      var Event = function Event(src, props) {\n        // Allow instantiation without the 'new' keyword\n        if (!(this instanceof Event)) {\n          return new Event(src, props);\n        } // Event object\n\n\n        if (src && src.type) {\n          this.originalEvent = src;\n          this.type = src.type; // Events bubbling up the document may have been marked as prevented\n          // by a handler lower down the tree; reflect the correct value.\n\n          this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse; // Event type\n        } else {\n          this.type = src;\n        } // Put explicitly provided properties onto the event object\n\n\n        if (props) {\n          // more efficient to manually copy fields we use\n          this.type = props.type !== undefined ? props.type : this.type;\n          this.namespace = props.namespace;\n          this.layout = props.layout;\n          this.data = props.data;\n          this.message = props.message;\n        } // Create a timestamp if incoming event doesn't have one\n\n\n        this.timeStamp = src && src.timeStamp || +new Date();\n      };\n\n      function returnFalse() {\n        return false;\n      }\n\n      function returnTrue() {\n        return true;\n      } // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n      // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n      Event.prototype = {\n        instanceString: function instanceString() {\n          return 'event';\n        },\n        preventDefault: function preventDefault() {\n          this.isDefaultPrevented = returnTrue;\n          var e = this.originalEvent;\n\n          if (!e) {\n            return;\n          } // if preventDefault exists run it on the original event\n\n\n          if (e.preventDefault) {\n            e.preventDefault();\n          }\n        },\n        stopPropagation: function stopPropagation() {\n          this.isPropagationStopped = returnTrue;\n          var e = this.originalEvent;\n\n          if (!e) {\n            return;\n          } // if stopPropagation exists run it on the original event\n\n\n          if (e.stopPropagation) {\n            e.stopPropagation();\n          }\n        },\n        stopImmediatePropagation: function stopImmediatePropagation() {\n          this.isImmediatePropagationStopped = returnTrue;\n          this.stopPropagation();\n        },\n        isDefaultPrevented: returnFalse,\n        isPropagationStopped: returnFalse,\n        isImmediatePropagationStopped: returnFalse\n      };\n      module.exports = Event;\n    }, {}],\n    3: [function (_dereq_, module, exports) {\n      /*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */\n      'use strict';\n\n      var is = _dereq_('./is');\n\n      var util = _dereq_('./util');\n\n      var Thread = _dereq_('./thread');\n\n      var Promise = _dereq_('./promise');\n\n      var define = _dereq_('./define');\n\n      var Fabric = function Fabric(N) {\n        if (!(this instanceof Fabric)) {\n          return new Fabric(N);\n        }\n\n        this._private = {\n          pass: []\n        };\n        var defN = 4;\n\n        if (is.number(N)) {// then use the specified number of threads\n        }\n\n        if (typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null) {\n          N = navigator.hardwareConcurrency;\n        } else {\n          try {\n            N = _dereq_('os').cpus().length;\n          } catch (err) {\n            N = defN;\n          }\n        } // TODO could use an estimation here but would the additional expense be worth it?\n\n\n        for (var i = 0; i < N; i++) {\n          this[i] = new Thread();\n        }\n\n        this.length = N;\n      };\n\n      var fabfn = Fabric.prototype; // short alias\n\n      util.extend(fabfn, {\n        instanceString: function instanceString() {\n          return 'fabric';\n        },\n        // require fn in all threads\n        require: function require(fn, as) {\n          for (var i = 0; i < this.length; i++) {\n            var thread = this[i];\n\n            thread.require(fn, as);\n          }\n\n          return this;\n        },\n        // get a random thread\n        random: function random() {\n          var i = Math.round((this.length - 1) * Math.random());\n          var thread = this[i];\n          return thread;\n        },\n        // run on random thread\n        run: function run(fn) {\n          var pass = this._private.pass.shift();\n\n          return this.random().pass(pass).run(fn);\n        },\n        // sends a random thread a message\n        message: function message(m) {\n          return this.random().message(m);\n        },\n        // send all threads a message\n        broadcast: function broadcast(m) {\n          for (var i = 0; i < this.length; i++) {\n            var thread = this[i];\n            thread.message(m);\n          }\n\n          return this; // chaining\n        },\n        // stop all threads\n        stop: function stop() {\n          for (var i = 0; i < this.length; i++) {\n            var thread = this[i];\n            thread.stop();\n          }\n\n          return this; // chaining\n        },\n        // pass data to be used with .spread() etc.\n        pass: function pass(data) {\n          var pass = this._private.pass;\n\n          if (is.array(data)) {\n            pass.push(data);\n          } else {\n            throw 'Only arrays may be used with fabric.pass()';\n          }\n\n          return this; // chaining\n        },\n        spreadSize: function spreadSize() {\n          var subsize = Math.ceil(this._private.pass[0].length / this.length);\n          subsize = Math.max(1, subsize); // don't pass less than one ele to each thread\n\n          return subsize;\n        },\n        // split the data into slices to spread the data equally among threads\n        spread: function spread(fn) {\n          var self = this;\n          var _p = self._private;\n          var subsize = self.spreadSize(); // number of pass eles to handle in each thread\n\n          var pass = _p.pass.shift().concat([]); // keep a copy\n\n\n          var runPs = [];\n\n          for (var i = 0; i < this.length; i++) {\n            var thread = this[i];\n            var slice = pass.splice(0, subsize);\n            var runP = thread.pass(slice).run(fn);\n            runPs.push(runP);\n            var doneEarly = pass.length === 0;\n\n            if (doneEarly) {\n              break;\n            }\n          }\n\n          return Promise.all(runPs).then(function (thens) {\n            var postpass = [];\n            var p = 0; // fill postpass with the total result joined from all threads\n\n            for (var i = 0; i < thens.length; i++) {\n              var then = thens[i]; // array result from thread i\n\n              for (var j = 0; j < then.length; j++) {\n                var t = then[j]; // array element\n\n                postpass[p++] = t;\n              }\n            }\n\n            return postpass;\n          });\n        },\n        // parallel version of array.map()\n        map: function map(fn) {\n          var self = this;\n\n          self.require(fn, '_$_$_fabmap');\n\n          return self.spread(function (split) {\n            var mapped = [];\n            var origResolve = resolve; // jshint ignore:line\n\n            resolve = function resolve(val) {\n              // jshint ignore:line\n              mapped.push(val);\n            };\n\n            for (var i = 0; i < split.length; i++) {\n              var oldLen = mapped.length;\n\n              var ret = _$_$_fabmap(split[i]); // jshint ignore:line\n\n\n              var nothingInsdByResolve = oldLen === mapped.length;\n\n              if (nothingInsdByResolve) {\n                mapped.push(ret);\n              }\n            }\n\n            resolve = origResolve; // jshint ignore:line\n\n            return mapped;\n          });\n        },\n        // parallel version of array.filter()\n        filter: function filter(fn) {\n          var _p = this._private;\n          var pass = _p.pass[0];\n          return this.map(fn).then(function (include) {\n            var ret = [];\n\n            for (var i = 0; i < pass.length; i++) {\n              var datum = pass[i];\n              var incDatum = include[i];\n\n              if (incDatum) {\n                ret.push(datum);\n              }\n            }\n\n            return ret;\n          });\n        },\n        // sorts the passed array using a divide and conquer strategy\n        sort: function sort(cmp) {\n          var self = this;\n          var P = this._private.pass[0].length;\n          var subsize = this.spreadSize();\n\n          cmp = cmp || function (a, b) {\n            // default comparison function\n            if (a < b) {\n              return -1;\n            } else if (a > b) {\n              return 1;\n            }\n\n            return 0;\n          };\n\n          self.require(cmp, '_$_$_cmp');\n\n          return self.spread(function (split) {\n            // sort each split normally\n            var sortedSplit = split.sort(_$_$_cmp); // jshint ignore:line\n\n            resolve(sortedSplit); // jshint ignore:line\n          }).then(function (joined) {\n            // do all the merging in the main thread to minimise data transfer\n            // TODO could do merging in separate threads but would incur add'l cost of data transfer\n            // for each level of the merge\n            var merge = function merge(i, j, max) {\n              // don't overflow array\n              j = Math.min(j, P);\n              max = Math.min(max, P); // left and right sides of merge\n\n              var l = i;\n              var r = j;\n              var sorted = [];\n\n              for (var k = l; k < max; k++) {\n                var eleI = joined[i];\n                var eleJ = joined[j];\n\n                if (i < r && (j >= max || cmp(eleI, eleJ) <= 0)) {\n                  sorted.push(eleI);\n                  i++;\n                } else {\n                  sorted.push(eleJ);\n                  j++;\n                }\n              } // in the array proper, put the sorted values\n\n\n              for (var k = 0; k < sorted.length; k++) {\n                // kth sorted item\n                var index = l + k;\n                joined[index] = sorted[k];\n              }\n            };\n\n            for (var splitL = subsize; splitL < P; splitL *= 2) {\n              // merge until array is \"split\" as 1\n              for (var i = 0; i < P; i += 2 * splitL) {\n                merge(i, i + splitL, i + 2 * splitL);\n              }\n            }\n\n            return joined;\n          });\n        }\n      });\n\n      var defineRandomPasser = function defineRandomPasser(opts) {\n        opts = opts || {};\n        return function (fn, arg1) {\n          var pass = this._private.pass.shift();\n\n          return this.random().pass(pass)[opts.threadFn](fn, arg1);\n        };\n      };\n\n      util.extend(fabfn, {\n        randomMap: defineRandomPasser({\n          threadFn: 'map'\n        }),\n        reduce: defineRandomPasser({\n          threadFn: 'reduce'\n        }),\n        reduceRight: defineRandomPasser({\n          threadFn: 'reduceRight'\n        })\n      }); // aliases\n\n      var fn = fabfn;\n      fn.promise = fn.run;\n      fn.terminate = fn.halt = fn.stop;\n      fn.include = fn.require; // pull in event apis\n\n      util.extend(fabfn, {\n        on: define.on(),\n        one: define.on({\n          unbindSelfOnTrigger: true\n        }),\n        off: define.off(),\n        trigger: define.trigger()\n      });\n      define.eventAliasesOn(fabfn);\n      module.exports = Fabric;\n    }, {\n      \"./define\": 1,\n      \"./is\": 5,\n      \"./promise\": 6,\n      \"./thread\": 7,\n      \"./util\": 8,\n      \"os\": undefined\n    }],\n    4: [function (_dereq_, module, exports) {\n      'use strict';\n\n      var Thread = _dereq_('./thread');\n\n      var Fabric = _dereq_('./fabric');\n\n      var weaver = function weaver() {\n        // jshint ignore:line\n        return;\n      };\n\n      weaver.version = '1.2.0';\n      weaver.thread = weaver.Thread = weaver.worker = weaver.Worker = Thread;\n      weaver.fabric = weaver.Fabric = Fabric;\n      module.exports = weaver;\n    }, {\n      \"./fabric\": 3,\n      \"./thread\": 7\n    }],\n    5: [function (_dereq_, module, exports) {\n      // type testing utility functions\n      'use strict';\n\n      var typeofstr = _typeof('');\n\n      var typeofobj = _typeof({});\n\n      var typeoffn = _typeof(function () {});\n\n      var instanceStr = function instanceStr(obj) {\n        return obj && obj.instanceString && is.fn(obj.instanceString) ? obj.instanceString() : null;\n      };\n\n      var is = {\n        defined: function defined(obj) {\n          return obj != null; // not undefined or null\n        },\n        string: function string(obj) {\n          return obj != null && _typeof(obj) == typeofstr;\n        },\n        fn: function fn(obj) {\n          return obj != null && _typeof(obj) === typeoffn;\n        },\n        array: function array(obj) {\n          return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;\n        },\n        plainObject: function plainObject(obj) {\n          return obj != null && _typeof(obj) === typeofobj && !is.array(obj) && obj.constructor === Object;\n        },\n        object: function object(obj) {\n          return obj != null && _typeof(obj) === typeofobj;\n        },\n        number: function number(obj) {\n          return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);\n        },\n        integer: function integer(obj) {\n          return is.number(obj) && Math.floor(obj) === obj;\n        },\n        bool: function bool(obj) {\n          return obj != null && _typeof(obj) === _typeof(true);\n        },\n        event: function event(obj) {\n          return instanceStr(obj) === 'event';\n        },\n        thread: function thread(obj) {\n          return instanceStr(obj) === 'thread';\n        },\n        fabric: function fabric(obj) {\n          return instanceStr(obj) === 'fabric';\n        },\n        emptyString: function emptyString(obj) {\n          if (!obj) {\n            // null is empty\n            return true;\n          } else if (is.string(obj)) {\n            if (obj === '' || obj.match(/^\\s+$/)) {\n              return true; // empty string is empty\n            }\n          }\n\n          return false; // otherwise, we don't know what we've got\n        },\n        nonemptyString: function nonemptyString(obj) {\n          if (obj && is.string(obj) && obj !== '' && !obj.match(/^\\s+$/)) {\n            return true;\n          }\n\n          return false;\n        }\n      };\n      module.exports = is;\n    }, {}],\n    6: [function (_dereq_, module, exports) {\n      // internal, minimal Promise impl s.t. apis can return promises in old envs\n      // based on thenable (http://github.com/rse/thenable)\n      'use strict';\n      /*  promise states [Promises/A+ 2.1]  */\n\n      var STATE_PENDING = 0;\n      /*  [Promises/A+ 2.1.1]  */\n\n      var STATE_FULFILLED = 1;\n      /*  [Promises/A+ 2.1.2]  */\n\n      var STATE_REJECTED = 2;\n      /*  [Promises/A+ 2.1.3]  */\n\n      /*  promise object constructor  */\n\n      var api = function api(executor) {\n        /*  optionally support non-constructor/plain-function call  */\n        if (!(this instanceof api)) return new api(executor);\n        /*  initialize object  */\n\n        this.id = \"Thenable/1.0.7\";\n        this.state = STATE_PENDING;\n        /*  initial state  */\n\n        this.fulfillValue = undefined;\n        /*  initial value  */\n\n        /*  [Promises/A+ 1.3, 2.1.2.2]  */\n\n        this.rejectReason = undefined;\n        /*  initial reason */\n\n        /*  [Promises/A+ 1.5, 2.1.3.2]  */\n\n        this.onFulfilled = [];\n        /*  initial handlers  */\n\n        this.onRejected = [];\n        /*  initial handlers  */\n\n        /*  provide optional information-hiding proxy  */\n\n        this.proxy = {\n          then: this.then.bind(this)\n        };\n        /*  support optional executor function  */\n\n        if (typeof executor === \"function\") executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n      };\n      /*  promise API methods  */\n\n\n      api.prototype = {\n        /*  promise resolving methods  */\n        fulfill: function fulfill(value) {\n          return deliver(this, STATE_FULFILLED, \"fulfillValue\", value);\n        },\n        reject: function reject(value) {\n          return deliver(this, STATE_REJECTED, \"rejectReason\", value);\n        },\n\n        /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */\n        then: function then(onFulfilled, onRejected) {\n          var curr = this;\n          var next = new api();\n          /*  [Promises/A+ 2.2.7]  */\n\n          curr.onFulfilled.push(resolver(onFulfilled, next, \"fulfill\"));\n          /*  [Promises/A+ 2.2.2/2.2.6]  */\n\n          curr.onRejected.push(resolver(onRejected, next, \"reject\"));\n          /*  [Promises/A+ 2.2.3/2.2.6]  */\n\n          execute(curr);\n          return next.proxy;\n          /*  [Promises/A+ 2.2.7, 3.3]  */\n        }\n      };\n      /*  deliver an action  */\n\n      var deliver = function deliver(curr, state, name, value) {\n        if (curr.state === STATE_PENDING) {\n          curr.state = state;\n          /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */\n\n          curr[name] = value;\n          /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */\n\n          execute(curr);\n        }\n\n        return curr;\n      };\n      /*  execute all handlers  */\n\n\n      var execute = function execute(curr) {\n        if (curr.state === STATE_FULFILLED) execute_handlers(curr, \"onFulfilled\", curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, \"onRejected\", curr.rejectReason);\n      };\n      /*  execute particular set of handlers  */\n\n\n      var execute_handlers = function execute_handlers(curr, name, value) {\n        /* global setImmediate: true */\n\n        /* global setTimeout: true */\n\n        /*  short-circuit processing  */\n        if (curr[name].length === 0) return;\n        /*  iterate over all handlers, exactly once  */\n\n        var handlers = curr[name];\n        curr[name] = [];\n        /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */\n\n        var func = function func() {\n          for (var i = 0; i < handlers.length; i++) {\n            handlers[i](value);\n          }\n          /*  [Promises/A+ 2.2.5]  */\n\n        };\n        /*  execute procedure asynchronously  */\n\n        /*  [Promises/A+ 2.2.4, 3.1]  */\n\n\n        if (typeof setImmediate === \"function\") setImmediate(func);else setTimeout(func, 0);\n      };\n      /*  generate a resolver function  */\n\n\n      var resolver = function resolver(cb, next, method) {\n        return function (value) {\n          if (typeof cb !== \"function\")\n            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */\n            next[method].call(next, value);\n            /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */\n          else {\n              var result;\n\n              try {\n                result = cb(value);\n              }\n              /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */\n              catch (e) {\n                next.reject(e);\n                /*  [Promises/A+ 2.2.7.2]  */\n\n                return;\n              }\n\n              resolve(next, result);\n              /*  [Promises/A+ 2.2.7.1]  */\n            }\n        };\n      };\n      /*  \"Promise Resolution Procedure\"  */\n\n      /*  [Promises/A+ 2.3]  */\n\n\n      var resolve = function resolve(promise, x) {\n        /*  sanity check arguments  */\n\n        /*  [Promises/A+ 2.3.1]  */\n        if (promise === x || promise.proxy === x) {\n          promise.reject(new TypeError(\"cannot resolve promise with itself\"));\n          return;\n        }\n        /*  surgically check for a \"then\" method\n          (mainly to just call the \"getter\" of \"then\" only once)  */\n\n\n        var then;\n\n        if (_typeof(x) === \"object\" && x !== null || typeof x === \"function\") {\n          try {\n            then = x.then;\n          }\n          /*  [Promises/A+ 2.3.3.1, 3.5]  */\n          catch (e) {\n            promise.reject(e);\n            /*  [Promises/A+ 2.3.3.2]  */\n\n            return;\n          }\n        }\n        /*  handle own Thenables    [Promises/A+ 2.3.2]\n          and similar \"thenables\" [Promises/A+ 2.3.3]  */\n\n\n        if (typeof then === \"function\") {\n          var resolved = false;\n\n          try {\n            /*  call retrieved \"then\" method */\n\n            /*  [Promises/A+ 2.3.3.3]  */\n            then.call(x,\n            /*  resolvePromise  */\n\n            /*  [Promises/A+ 2.3.3.3.1]  */\n            function (y) {\n              if (resolved) return;\n              resolved = true;\n              /*  [Promises/A+ 2.3.3.3.3]  */\n\n              if (y === x)\n                /*  [Promises/A+ 3.6]  */\n                promise.reject(new TypeError(\"circular thenable chain\"));else resolve(promise, y);\n            },\n            /*  rejectPromise  */\n\n            /*  [Promises/A+ 2.3.3.3.2]  */\n            function (r) {\n              if (resolved) return;\n              resolved = true;\n              /*  [Promises/A+ 2.3.3.3.3]  */\n\n              promise.reject(r);\n            });\n          } catch (e) {\n            if (!resolved)\n              /*  [Promises/A+ 2.3.3.3.3]  */\n              promise.reject(e);\n            /*  [Promises/A+ 2.3.3.3.4]  */\n          }\n\n          return;\n        }\n        /*  handle other values  */\n\n\n        promise.fulfill(x);\n        /*  [Promises/A+ 2.3.4, 2.3.3.4]  */\n      }; // use native promises where possible\n\n\n      var Promise = typeof Promise === 'undefined' ? api : Promise; // so we always have Promise.all()\n\n      Promise.all = Promise.all || function (ps) {\n        return new Promise(function (resolveAll, rejectAll) {\n          var vals = new Array(ps.length);\n          var doneCount = 0;\n\n          var fulfill = function fulfill(i, val) {\n            vals[i] = val;\n            doneCount++;\n\n            if (doneCount === ps.length) {\n              resolveAll(vals);\n            }\n          };\n\n          for (var i = 0; i < ps.length; i++) {\n            (function (i) {\n              var p = ps[i];\n              var isPromise = p.then != null;\n\n              if (isPromise) {\n                p.then(function (val) {\n                  fulfill(i, val);\n                }, function (err) {\n                  rejectAll(err);\n                });\n              } else {\n                var val = p;\n                fulfill(i, val);\n              }\n            })(i);\n          }\n        });\n      };\n\n      module.exports = Promise;\n    }, {}],\n    7: [function (_dereq_, module, exports) {\n      /*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */\n      // cross-env thread/worker\n      // NB : uses (heavyweight) processes on nodejs so best not to create too many threads\n      'use strict';\n\n      var window = _dereq_('./window');\n\n      var util = _dereq_('./util');\n\n      var Promise = _dereq_('./promise');\n\n      var Event = _dereq_('./event');\n\n      var define = _dereq_('./define');\n\n      var is = _dereq_('./is');\n\n      var Thread = function Thread(opts) {\n        if (!(this instanceof Thread)) {\n          return new Thread(opts);\n        }\n\n        var _p = this._private = {\n          requires: [],\n          files: [],\n          queue: null,\n          pass: [],\n          disabled: false\n        };\n\n        if (is.plainObject(opts)) {\n          if (opts.disabled != null) {\n            _p.disabled = !!opts.disabled;\n          }\n        }\n      };\n\n      var thdfn = Thread.prototype; // short alias\n\n      var stringifyFieldVal = function stringifyFieldVal(val) {\n        var valStr = is.fn(val) ? val.toString() : \"JSON.parse('\" + JSON.stringify(val) + \"')\";\n        return valStr;\n      }; // allows for requires with prototypes and subobjs etc\n\n\n      var fnAsRequire = function fnAsRequire(fn) {\n        var req;\n        var fnName;\n\n        if (is.object(fn) && fn.fn) {\n          // manual fn\n          req = fnAs(fn.fn, fn.name);\n          fnName = fn.name;\n          fn = fn.fn;\n        } else if (is.fn(fn)) {\n          // auto fn\n          req = fn.toString();\n          fnName = fn.name;\n        } else if (is.string(fn)) {\n          // stringified fn\n          req = fn;\n        } else if (is.object(fn)) {\n          // plain object\n          if (fn.proto) {\n            req = '';\n          } else {\n            req = fn.name + ' = {};';\n          }\n\n          fnName = fn.name;\n          fn = fn.obj;\n        }\n\n        req += '\\n';\n\n        var protoreq = function protoreq(val, subname) {\n          if (val.prototype) {\n            var protoNonempty = false;\n\n            for (var prop in val.prototype) {\n              protoNonempty = true;\n              break;\n            } // jshint ignore:line\n\n\n            if (protoNonempty) {\n              req += fnAsRequire({\n                name: subname,\n                obj: val,\n                proto: true\n              }, val);\n            }\n          }\n        }; // pull in prototype\n\n\n        if (fn.prototype && fnName != null) {\n          for (var name in fn.prototype) {\n            var protoStr = '';\n            var val = fn.prototype[name];\n            var valStr = stringifyFieldVal(val);\n            var subname = fnName + '.prototype.' + name;\n            protoStr += subname + ' = ' + valStr + ';\\n';\n\n            if (protoStr) {\n              req += protoStr;\n            }\n\n            protoreq(val, subname); // subobject with prototype\n          }\n        } // pull in properties for obj/fns\n\n\n        if (!is.string(fn)) {\n          for (var name in fn) {\n            var propsStr = '';\n\n            if (fn.hasOwnProperty(name)) {\n              var val = fn[name];\n              var valStr = stringifyFieldVal(val);\n              var subname = fnName + '[\"' + name + '\"]';\n              propsStr += subname + ' = ' + valStr + ';\\n';\n            }\n\n            if (propsStr) {\n              req += propsStr;\n            }\n\n            protoreq(val, subname); // subobject with prototype\n          }\n        }\n\n        return req;\n      };\n\n      var isPathStr = function isPathStr(str) {\n        return is.string(str) && str.match(/\\.js$/);\n      };\n\n      util.extend(thdfn, {\n        instanceString: function instanceString() {\n          return 'thread';\n        },\n        require: function require(fn, as) {\n          var requires = this._private.requires;\n\n          if (isPathStr(fn)) {\n            this._private.files.push(fn);\n\n            return this;\n          }\n\n          if (as) {\n            if (is.fn(fn)) {\n              fn = {\n                name: as,\n                fn: fn\n              };\n            } else {\n              fn = {\n                name: as,\n                obj: fn\n              };\n            }\n          } else {\n            if (is.fn(fn)) {\n              if (!fn.name) {\n                throw 'The function name could not be automatically determined.  Use thread.require( someFunction, \"someFunction\" )';\n              }\n\n              fn = {\n                name: fn.name,\n                fn: fn\n              };\n            }\n          }\n\n          requires.push(fn);\n          return this; // chaining\n        },\n        pass: function pass(data) {\n          this._private.pass.push(data);\n\n          return this; // chaining\n        },\n        run: function run(fn, pass) {\n          // fn used like main()\n          var self = this;\n          var _p = this._private;\n          pass = pass || _p.pass.shift();\n\n          if (_p.stopped) {\n            throw 'Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.';\n          }\n\n          if (_p.running) {\n            return _p.queue = _p.queue.then(function () {\n              // inductive step\n              return self.run(fn, pass);\n            });\n          }\n\n          var useWW = window != null && !_p.disabled;\n          var useNode = !window && typeof module !== 'undefined' && !_p.disabled;\n          self.trigger('run');\n          var runP = new Promise(function (resolve, reject) {\n            _p.running = true;\n            var threadTechAlreadyExists = _p.ran;\n            var fnImplStr = is.string(fn) ? fn : fn.toString(); // worker code to exec\n\n            var fnStr = '\\n' + _p.requires.map(function (r) {\n              return fnAsRequire(r);\n            }).concat(_p.files.map(function (f) {\n              if (useWW) {\n                var wwifyFile = function wwifyFile(file) {\n                  if (file.match(/^\\.\\//) || file.match(/^\\.\\./)) {\n                    return window.location.origin + window.location.pathname + file;\n                  } else if (file.match(/^\\//)) {\n                    return window.location.origin + '/' + file;\n                  }\n\n                  return file;\n                };\n\n                return 'importScripts(\"' + wwifyFile(f) + '\");';\n              } else if (useNode) {\n                return 'eval( require(\"fs\").readFileSync(\"' + f + '\", { encoding: \"utf8\" }) );';\n              } else {\n                throw 'External file `' + f + '` can not be required without any threading technology.';\n              }\n            })).concat(['( function(){', 'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');', 'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it\n            '} )()\\n']).join('\\n'); // because we've now consumed the requires, empty the list so we don't dupe on next run()\n\n\n            _p.requires = [];\n            _p.files = [];\n\n            if (useWW) {\n              var fnBlob, fnUrl; // add normalised thread api functions\n\n              if (!threadTechAlreadyExists) {\n                var fnPre = fnStr + '';\n                fnStr = ['function _ref_(o){ return eval(o); };', 'function broadcast(m){ return message(m); };', // alias\n                'function message(m){ postMessage(m); };', 'function listen(fn){', '  self.addEventListener(\"message\", function(m){ ', '    if( typeof m === \"object\" && (m.data.$$eval || m.data === \"$$start\") ){', '    } else { ', '      fn( m.data );', '    }', '  });', '};', 'self.addEventListener(\"message\", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });', 'function resolve(v){ postMessage({ $$resolve: v }); };', 'function reject(v){ postMessage({ $$reject: v }); };'].join('\\n');\n                fnStr += fnPre;\n                fnBlob = new Blob([fnStr], {\n                  type: 'application/javascript'\n                });\n                fnUrl = window.URL.createObjectURL(fnBlob);\n              } // create webworker and let it exec the serialised code\n\n\n              var ww = _p.webworker = _p.webworker || new Worker(fnUrl);\n\n              if (threadTechAlreadyExists) {\n                // then just exec new run() code\n                ww.postMessage({\n                  $$eval: fnStr\n                });\n              } // worker messages => events\n\n\n              var _cb2;\n\n              ww.addEventListener('message', _cb2 = function cb(m) {\n                var isObject = is.object(m) && is.object(m.data);\n\n                if (isObject && '$$resolve' in m.data) {\n                  ww.removeEventListener('message', _cb2); // done listening b/c resolve()\n\n                  resolve(m.data.$$resolve);\n                } else if (isObject && '$$reject' in m.data) {\n                  ww.removeEventListener('message', _cb2); // done listening b/c reject()\n\n                  reject(m.data.$$reject);\n                } else {\n                  self.trigger(new Event(m, {\n                    type: 'message',\n                    message: m.data\n                  }));\n                }\n              }, false);\n\n              if (!threadTechAlreadyExists) {\n                ww.postMessage('$$start'); // start up the worker\n              }\n            } else if (useNode) {\n              // create a new process\n              if (!_p.child) {\n                _p.child = _dereq_('child_process').fork(_dereq_('path').join(__dirname, 'thread-node-fork'));\n              }\n\n              var child = _p.child; // child process messages => events\n\n              var _cb2;\n\n              child.on('message', _cb2 = function _cb(m) {\n                if (is.object(m) && '$$resolve' in m) {\n                  child.removeListener('message', _cb2); // done listening b/c resolve()\n\n                  resolve(m.$$resolve);\n                } else if (is.object(m) && '$$reject' in m) {\n                  child.removeListener('message', _cb2); // done listening b/c reject()\n\n                  reject(m.$$reject);\n                } else {\n                  self.trigger(new Event({}, {\n                    type: 'message',\n                    message: m\n                  }));\n                }\n              }); // ask the child process to eval the worker code\n\n              child.send({\n                $$eval: fnStr\n              });\n            } else {\n              // use a fallback mechanism using a timeout\n              var promiseResolve = resolve;\n              var promiseReject = reject;\n              var timer = _p.timer = _p.timer || {\n                listeners: [],\n                exec: function exec() {\n                  // as a string so it can't be mangled by minifiers and processors\n                  fnStr = ['function _ref_(o){ return eval(o); };', 'function broadcast(m){ return message(m); };', 'function message(m){ self.trigger( new Event({}, { type: \"message\", message: m }) ); };', 'function listen(fn){ timer.listeners.push( fn ); };', 'function resolve(v){ promiseResolve(v); };', 'function reject(v){ promiseReject(v); };'].join('\\n') + fnStr; // the .run() code\n\n                  eval(fnStr); // jshint ignore:line\n                },\n                message: function message(m) {\n                  var ls = timer.listeners;\n\n                  for (var i = 0; i < ls.length; i++) {\n                    var fn = ls[i];\n                    fn(m);\n                  }\n                }\n              };\n              timer.exec();\n            }\n          }).then(function (v) {\n            _p.running = false;\n            _p.ran = true;\n            self.trigger('ran');\n            return v;\n          });\n\n          if (_p.queue == null) {\n            _p.queue = runP; // i.e. first step of inductive promise chain (for queue)\n          }\n\n          return runP;\n        },\n        // send the thread a message\n        message: function message(m) {\n          var _p = this._private;\n\n          if (_p.webworker) {\n            _p.webworker.postMessage(m);\n          }\n\n          if (_p.child) {\n            _p.child.send(m);\n          }\n\n          if (_p.timer) {\n            _p.timer.message(m);\n          }\n\n          return this; // chaining\n        },\n        stop: function stop() {\n          var _p = this._private;\n\n          if (_p.webworker) {\n            _p.webworker.terminate();\n          }\n\n          if (_p.child) {\n            _p.child.kill();\n          }\n\n          if (_p.timer) {// nothing we can do if we've run a timeout\n          }\n\n          _p.stopped = true;\n          return this.trigger('stop'); // chaining\n        },\n        stopped: function stopped() {\n          return this._private.stopped;\n        }\n      }); // turns a stringified function into a (re)named function\n\n      var fnAs = function fnAs(fn, name) {\n        var fnStr = fn.toString();\n        fnStr = fnStr.replace(/function\\s*?\\S*?\\s*?\\(/, 'function ' + name + '(');\n        return fnStr;\n      };\n\n      var defineFnal = function defineFnal(opts) {\n        opts = opts || {};\n        return function fnalImpl(fn, arg1) {\n          var fnStr = fnAs(fn, '_$_$_' + opts.name);\n\n          this.require(fnStr);\n\n          return this.run(['function( data ){', '  var origResolve = resolve;', '  var res = [];', '  ', '  resolve = function( val ){', '    res.push( val );', '  };', '  ', '  var ret = data.' + opts.name + '( _$_$_' + opts.name + (arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '') + ' );', '  ', '  resolve = origResolve;', '  resolve( res.length > 0 ? res : ret );', '}'].join('\\n'));\n        };\n      };\n\n      util.extend(thdfn, {\n        reduce: defineFnal({\n          name: 'reduce'\n        }),\n        reduceRight: defineFnal({\n          name: 'reduceRight'\n        }),\n        map: defineFnal({\n          name: 'map'\n        })\n      }); // aliases\n\n      var fn = thdfn;\n      fn.promise = fn.run;\n      fn.terminate = fn.halt = fn.stop;\n      fn.include = fn.require; // pull in event apis\n\n      util.extend(thdfn, {\n        on: define.on(),\n        one: define.on({\n          unbindSelfOnTrigger: true\n        }),\n        off: define.off(),\n        trigger: define.trigger()\n      });\n      define.eventAliasesOn(thdfn);\n      module.exports = Thread;\n    }, {\n      \"./define\": 1,\n      \"./event\": 2,\n      \"./is\": 5,\n      \"./promise\": 6,\n      \"./util\": 8,\n      \"./window\": 9,\n      \"child_process\": undefined,\n      \"path\": undefined\n    }],\n    8: [function (_dereq_, module, exports) {\n      'use strict';\n\n      var is = _dereq_('./is');\n\n      var util; // utility functions only for internal use\n\n      util = {\n        // the jquery extend() function\n        // NB: modified to use is etc since we can't use jquery functions\n        extend: function extend() {\n          var options,\n              name,\n              src,\n              copy,\n              copyIsArray,\n              clone,\n              target = arguments[0] || {},\n              i = 1,\n              length = arguments.length,\n              deep = false; // Handle a deep copy situation\n\n          if (typeof target === 'boolean') {\n            deep = target;\n            target = arguments[1] || {}; // skip the boolean and the target\n\n            i = 2;\n          } // Handle case when target is a string or something (possible in deep copy)\n\n\n          if (_typeof(target) !== 'object' && !is.fn(target)) {\n            target = {};\n          } // extend jQuery itself if only one argument is passed\n\n\n          if (length === i) {\n            target = this;\n            --i;\n          }\n\n          for (; i < length; i++) {\n            // Only deal with non-null/undefined values\n            if ((options = arguments[i]) != null) {\n              // Extend the base object\n              for (name in options) {\n                src = target[name];\n                copy = options[name]; // Prevent never-ending loop\n\n                if (target === copy) {\n                  continue;\n                } // Recurse if we're merging plain objects or arrays\n\n\n                if (deep && copy && (is.plainObject(copy) || (copyIsArray = is.array(copy)))) {\n                  if (copyIsArray) {\n                    copyIsArray = false;\n                    clone = src && is.array(src) ? src : [];\n                  } else {\n                    clone = src && is.plainObject(src) ? src : {};\n                  } // Never move original objects, clone them\n\n\n                  target[name] = util.extend(deep, clone, copy); // Don't bring in undefined values\n                } else if (copy !== undefined) {\n                  target[name] = copy;\n                }\n              }\n            }\n          } // Return the modified object\n\n\n          return target;\n        },\n        error: function error(msg) {\n          if (console) {\n            if (console.error) {\n              console.error.apply(console, arguments);\n            } else if (console.log) {\n              console.log.apply(console, arguments);\n            } else {\n              throw msg;\n            }\n          } else {\n            throw msg;\n          }\n        }\n      };\n      module.exports = util;\n    }, {\n      \"./is\": 5\n    }],\n    9: [function (_dereq_, module, exports) {\n      module.exports = typeof window === 'undefined' ? null : window;\n    }, {}]\n  }, {}, [4])(4);\n});","map":null,"metadata":{},"sourceType":"script"}