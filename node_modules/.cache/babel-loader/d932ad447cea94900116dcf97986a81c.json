{"ast":null,"code":"var _typeof2 = require(\"@babel/runtime/helpers/typeof\");\n\n(function webpackUniversalModuleDefinition(root, factory) {\n  if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof2(exports)) === 'object' && (typeof module === \"undefined\" ? \"undefined\" : _typeof2(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof2(exports)) === 'object') exports[\"Phylocanvas\"] = factory();else root[\"Phylocanvas\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId])\n          /******/\n          return installedModules[moduleId].exports;\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n        var module = installedModules[moduleId] = {\n          /******/\n          exports: {},\n\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false\n          /******/\n\n        };\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.loaded = true;\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n      __webpack_require__.p = \"/dist/\";\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.utils = exports.nodeRenderers = exports.treeTypes = exports.Parser = exports.Tooltip = exports.Prerenderer = exports.Branch = exports.Tree = undefined;\n\n      var _Tree = __webpack_require__(1);\n\n      var _Tree2 = _interopRequireDefault(_Tree);\n\n      var _Branch = __webpack_require__(7);\n\n      var _Branch2 = _interopRequireDefault(_Branch);\n\n      var _Prerenderer = __webpack_require__(11);\n\n      var _Prerenderer2 = _interopRequireDefault(_Prerenderer);\n\n      var _Tooltip = __webpack_require__(27);\n\n      var _Tooltip2 = _interopRequireDefault(_Tooltip);\n\n      var _Parser = __webpack_require__(29);\n\n      var _Parser2 = _interopRequireDefault(_Parser);\n\n      var _treeTypes = __webpack_require__(8);\n\n      var _treeTypes2 = _interopRequireDefault(_treeTypes);\n\n      var _nodeRenderers = __webpack_require__(26);\n\n      var _nodeRenderers2 = _interopRequireDefault(_nodeRenderers);\n\n      var _utils = __webpack_require__(2);\n\n      var utils = _interopRequireWildcard(_utils);\n\n      function _interopRequireWildcard(obj) {\n        if (obj && obj.__esModule) {\n          return obj;\n        } else {\n          var newObj = {};\n\n          if (obj != null) {\n            for (var key in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n            }\n          }\n\n          newObj.default = obj;\n          return newObj;\n        }\n      }\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function decorate(object, fnName, fn) {\n        var target = object[fnName] ? object : object.prototype;\n        var originalFn = target[fnName];\n\n        target[fnName] = function () {\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return fn.call(this, originalFn, args);\n        };\n      }\n      /**\n       * The publicly exported module. Exports the following methods by default, and\n       * contains named exports of internal classes, types, and utils.\n       *\n       * @module Phylocanvas\n       */\n\n\n      exports.Tree = _Tree2.default;\n      exports.Branch = _Branch2.default;\n      exports.Prerenderer = _Prerenderer2.default;\n      exports.Tooltip = _Tooltip2.default;\n      exports.Parser = _Parser2.default;\n      exports.treeTypes = _treeTypes2.default;\n      exports.nodeRenderers = _nodeRenderers2.default;\n      exports.utils = utils;\n      /**\n       * Register a plugin.\n       *\n       * @param {function} pluginFn - Imported plugin module.\n       */\n\n      function plugin(pluginFn) {\n        pluginFn.call(this, decorate);\n      }\n      /**\n       * A factory function for Phylocanvas instances to enable decoration by plugins.\n       *\n       * @param {string|HTMLElement} element - ID or element within which to place Phylocanvas instance.\n       * @param {Object} config - Configuration object, properties are copied into the {@link Tree} object.\n       *\n       * @return An instance of {@link Tree}.\n       */\n\n\n      function createTree(element) {\n        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new _Tree2.default(element, config);\n      }\n\n      exports.default = {\n        plugin: plugin,\n        createTree: createTree\n      };\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _utils = __webpack_require__(2);\n\n      var _Branch = __webpack_require__(7);\n\n      var _Branch2 = _interopRequireDefault(_Branch);\n\n      var _Tooltip = __webpack_require__(27);\n\n      var _treeTypes = __webpack_require__(8);\n\n      var _treeTypes2 = _interopRequireDefault(_treeTypes);\n\n      var _parsers = __webpack_require__(28);\n\n      var _parsers2 = _interopRequireDefault(_parsers);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _toConsumableArray(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var addClass = _utils.dom.addClass,\n          setCursorDrag = _utils.dom.setCursorDrag,\n          setCursorDragging = _utils.dom.setCursorDragging;\n      var fireEvent = _utils.events.fireEvent,\n          addEvent = _utils.events.addEvent,\n          removeEvent = _utils.events.removeEvent;\n      var getPixelRatio = _utils.canvas.getPixelRatio,\n          translateClick = _utils.canvas.translateClick;\n      var Predicates = _utils.constants.Predicates;\n      /**\n       * A Phylocanvas instance.\n       *\n       * @class\n       * @see module:Phylocanvas~createTree\n       */\n\n      var Tree = function () {\n        /**\n         * @constructor\n         * @param {string|HTMLElement} element\n         * @param {Object} config\n         */\n        function Tree(element) {\n          var _this = this;\n\n          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          _classCallCheck(this, Tree);\n\n          this._point = {\n            x: 0,\n            y: 0\n          };\n          /**\n           * Places the instance in the DOM. Events are triggered from here.\n           *\n           * @type HTMLElement\n           */\n\n          this.containerElement = typeof element === 'string' ? document.getElementById(element) : element;\n          addClass(this.containerElement, 'pc-container');\n          /**\n           * Dictionary of {@link Branch} objects indexed by ID.\n           *\n           * @type {Object.<string, Branch>}\n           */\n\n          this.branches = {};\n          /**\n           * List of leaves.\n           *\n           * @type Array.<Branch>\n           */\n\n          this.leaves = [];\n          /**\n           * The root node of the tree\n           * (not neccesarily a root in the Phylogenetic sense)\n           *\n           * @type Branch\n           */\n\n          this.root = false;\n          /**\n           * Stores the unparsed tree.\n           *\n           * @type string\n           */\n\n          this.stringRepresentation = '';\n          /**\n           * Colour the branches of the tree based on the colour of the tips.\n           *\n           * @type boolean\n           */\n\n          this.backColour = false;\n          /**\n           * Stores the state of the tree after parsing.\n           *\n           * @type Object\n           */\n\n          this.originalTree = {}; // Set up the element and canvas\n\n          if (window.getComputedStyle(this.containerElement).position === 'static') {\n            this.containerElement.style.position = 'relative';\n          }\n\n          this.containerElement.style.boxSizing = 'border-box';\n          var canvasElement = document.createElement('canvas');\n          canvasElement.id = (this.containerElement.id || '') + '__canvas';\n          canvasElement.className = 'phylocanvas';\n          canvasElement.style.position = 'relative';\n          canvasElement.height = element.offsetHeight || 400;\n          canvasElement.width = element.offsetWidth || 400;\n          canvasElement.style.zIndex = '1';\n          this.containerElement.appendChild(canvasElement);\n          /**\n           * Canvas drawing context.\n           *\n           * @type CanvasRenderingContext2D\n           */\n\n          this.canvas = canvasElement.getContext('2d');\n\n          this.canvas.canvas.onselectstart = function () {\n            return false;\n          };\n\n          this.canvas.fillStyle = '#000000';\n          this.canvas.strokeStyle = '#000000';\n          this.canvas.save();\n          /**\n           * Colour for collapsed sections of the tree.\n           *\n           * @type string\n           */\n\n          this.collapsedColour = 'rgba(0, 0, 0, 0.5)';\n          /**\n           * A minimum and maximum number of child branches within which to\n           * automatically collapse branches on the first draw.\n           *\n           * @type object\n           * @property {number} min\n           * @property {number} max\n           */\n\n          this.defaultCollapsed = {};\n          /**\n           * The default tooltip showing number of child branches.\n           *\n           * @type Tooltip\n           */\n\n          this.tooltip = new _Tooltip.ChildNodesTooltip(this);\n          /**\n           * Has Tree been drawn already, true after first draw.\n           *\n           * @type boolean\n           */\n\n          this.drawn = false;\n          /**\n           * Stores highlighting functions used during drawing.\n           *\n           * @type Array.<Function>\n           */\n\n          this.highlighters = [];\n          /**\n           * The current level of zoom.\n           *\n           * @type number\n           */\n\n          this.zoom = 1;\n          /**\n           * Controls the speed of zooming. Recommended values are between 1 and 5.\n           *\n           * @type number\n           * @default\n           */\n\n          this.zoomFactor = 3;\n          /**\n           * @type boolean\n           * @default\n           */\n\n          this.disableZoom = false;\n          /**\n           * Force rectangular and hierarchical trees to use the canvas dimensions\n           * instead of the number of leaves for proportion at the prerender stage.\n           *\n           * @type boolean\n           */\n\n          this.fillCanvas = false;\n          /**\n           * Enable branch scaling.\n           *\n           * @type boolean\n           * @default\n           */\n\n          this.branchScaling = true;\n          /**\n           * The current branch scale.\n           *\n           * @type number\n           */\n\n          this.currentBranchScale = 1;\n          /**\n           * The ratio at which branches scale.\n           *\n           * @type number\n           */\n\n          this.branchScalingStep = 1.2;\n          /**\n           * Whether a click has been detected.\n           *\n           * @type boolean\n           */\n\n          this.pickedup = false;\n          /**\n           * Whether the user is dragging.\n           *\n           * @type boolean\n           */\n\n          this.dragging = false;\n          /**\n           * The starting x coordinate of a drag.\n           *\n           * @type number\n           */\n\n          this.startx = null;\n          /**\n           * The starting y coordinate of a drag.\n           *\n           * @type number\n           */\n\n          this.starty = null;\n          /**\n           * Factor with which to scale the radius of a leaf.\n           *\n           * @type number\n           * @default\n           */\n\n          this.baseNodeSize = 1;\n          /**\n           * Caches the offsetx when a click is detected.\n           *\n           * @type number\n           */\n\n          this.origx = null;\n          /**\n           * Caches the offsety when a click is detected.\n           *\n           * @type number\n           */\n\n          this.origy = null;\n          /**\n           * The x coordinate from which to begin drawing from.\n           *\n           * @type number\n           */\n\n          this.offsetx = this.canvas.canvas.width / 2;\n          /**\n           * The y coordinate from which to begin drawing from.\n           *\n           * @type number\n           */\n\n          this.offsety = this.canvas.canvas.height / 2;\n          /**\n           * The colour to apply to a selected branch.\n           *\n           * @type string\n           * @default\n           */\n\n          this.selectedColour = 'rgba(49,151,245,1)';\n          /**\n           * The colour to apply to a hihglighted branch.\n           *\n           * @type string\n           * @default\n           */\n\n          this.highlightColour = 'rgba(49,151,245,1)';\n          /**\n           * The line width of the halo on a highlighted branch.\n           *\n           * @type number\n           * @default\n           */\n\n          this.highlightWidth = 4;\n          /**\n           * Scale factor for the size of the the halo on a highlighted branch.\n           *\n           * @type number\n           * @default\n           */\n\n          this.highlightSize = 2;\n          /**\n           * Global branch colour,\n           *\n           * @type string\n           * @default\n           */\n\n          this.branchColour = 'rgba(0,0,0,1)';\n          /**\n           * Scale factor applied to branch lengths defined in the serialised\n           * representation of the tree.\n           *\n           * @type number\n           */\n\n          this.branchScalar = 1.0;\n          /**\n           * Space to add to bounds when fitting the tree to the canvas.\n           *\n           * @type number\n           * @default\n           */\n\n          this.padding = 50;\n          /**\n           * Space between a leaf and its label.\n           *\n           * @type number\n           * @default\n           */\n\n          this.labelPadding = 5;\n          /**\n           * Enable/disable shift-click multi-selection.\n           *\n           * @type boolean\n           * @default\n           */\n\n          this.multiSelect = true;\n          /**\n           * Flag to change on branch when clicked.\n           *\n           * @type string\n           * @default\n           */\n\n          this.clickFlag = 'selected';\n          /**\n           * Decide if a branch should be affected when clicked.\n           *\n           * @type function\n           *\n           * @param {Branch} branch\n           * @param {string} property\n           * @param {} value\n           *\n           * @return boolean\n           * @default A function returning true.\n           */\n\n          this.clickFlagPredicate = Predicates.tautology;\n          /**\n           * Show labels when hovering over node.\n           *\n           * @type boolean\n           * @default\n           */\n\n          this.hoverLabel = false;\n          /**\n           * @type boolean\n           * @default\n           */\n\n          this.internalNodesSelectable = true;\n          /**\n           * @type boolean\n           * @default\n           */\n\n          this.showLabels = true;\n          /**\n           * Global show/hide branch-length labels.\n           *\n           * @type boolean\n           * @default\n           */\n\n          this.showBranchLengthLabels = false;\n          /**\n           * Conditionally display branch-length labels when enabled.\n           *\n           * @type function\n           * @param {Branch} node\n           * @default\n           */\n\n          this.branchLengthLabelPredicate = Predicates.tautology;\n          /**\n           * @type boolean\n           * @default\n           */\n\n          this.showInternalNodeLabels = false;\n          /**\n           * Global style for internal labels on branches.\n           *\n           * @type object\n           * @property {string} colour\n           * @property {number} textSize\n           * @property {string} font\n           * @property {string} format - e.g. bold, italic\n           */\n\n          this.internalLabelStyle = {\n            colour: this.branchColour,\n            textSize: this.textSize,\n            font: this.font,\n            format: ''\n          };\n          this.setTreeType('radial');\n          /**\n           * Stores the length of the longest branch on the tree.\n           *\n           * @type number\n           */\n\n          this.maxBranchLength = 0;\n          /**\n           * The visible width of the branches.\n           *\n           * @type number\n           * @default\n           */\n\n          this.lineWidth = 1.0;\n          /**\n           * The size of the labels, scaled to the size of the tree on first draw.\n           *\n           * @type number\n           */\n\n          this.textSize = 7;\n          /**\n           * The font of the labels.\n           *\n           * @type string\n           */\n\n          this.font = 'sans-serif';\n          /**\n           * @type boolean\n           * @default\n           */\n\n          this.unselectOnClickAway = true;\n          /**\n           * X coordinate of node that is furthest from the root.\n           *\n           * @type number\n           */\n\n          this.farthestNodeFromRootX = 0;\n          /**\n           * Y coordinate of node that is furthest from the root.\n           *\n           * @type number\n           */\n\n          this.farthestNodeFromRootY = 0;\n          /**\n           * Require the 'shift' key to be depressed to allow dragging\n           */\n\n          this.shiftKeyDrag = false;\n          /**\n           * Maximum length of label for each tree type.\n           *\n           * @type Object.<string, number>\n           */\n\n          this.maxLabelLength = {}; // Override properties from config\n\n          Object.assign(this, config);\n          this.resizeToContainer();\n          /**\n           * Event listener cache.\n           *\n           * @type object\n           */\n\n          this.eventListeners = {};\n          /**\n           * Default event listeners. Listeners passed in `config.eventListeners` will\n           * overwrite the listener of the same type.\n           */\n\n          var eventListeners = Object.assign({\n            click: {\n              listener: this.clicked.bind(this)\n            },\n            mousedown: {\n              listener: this.pickup.bind(this)\n            },\n            mouseup: {\n              listener: this.drop.bind(this)\n            },\n            mouseout: {\n              listener: this.drop.bind(this)\n            },\n            mousemove: {\n              target: this.canvas.canvas,\n              listener: this.drag.bind(this)\n            },\n            mousewheel: {\n              target: this.canvas.canvas,\n              listener: this.scroll.bind(this)\n            },\n            DOMMouseScroll: {\n              target: this.canvas.canvas,\n              listener: this.scroll.bind(this)\n            },\n            resize: {\n              target: window,\n              listener: function listener() {\n                _this.resizeToContainer();\n\n                _this.draw();\n              }\n            }\n          }, config.eventListeners || {});\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = Object.keys(eventListeners)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var event = _step.value;\n              var _eventListeners$event = eventListeners[event],\n                  listener = _eventListeners$event.listener,\n                  target = _eventListeners$event.target;\n              this.addListener(event, listener, target);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n        /**\n         * Removes events defined in this.eventListeners. Useful for cleaning up.\n         */\n\n\n        _createClass(Tree, [{\n          key: 'removeEventListeners',\n          value: function removeEventListeners() {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = Object.keys(this.eventListeners)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var event = _step2.value;\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                  for (var _iterator3 = this.eventListeners[event][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var def = _step3.value;\n                    var target = def.target,\n                        listener = def.listener;\n                    removeEvent(target || this.containerElement, event, listener);\n                  }\n                } catch (err) {\n                  _didIteratorError3 = true;\n                  _iteratorError3 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                      _iterator3.return();\n                    }\n                  } finally {\n                    if (_didIteratorError3) {\n                      throw _iteratorError3;\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          }\n          /**\n           * Set/get if labels are currently aligned.\n           *\n           * @type boolean\n           */\n\n        }, {\n          key: 'setInitialCollapsedBranches',\n\n          /**\n           * Collapses branches based on {@link Tree#defaultCollapsed}.\n           *\n           * @param {Branch} [node=this.root]\n           */\n          value: function setInitialCollapsedBranches() {\n            var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.root;\n            var childIds;\n            var i;\n            childIds = node.getChildProperties('id');\n\n            if (childIds && childIds.length > this.defaultCollapsed.min && childIds.length < this.defaultCollapsed.max) {\n              node.collapsed = true;\n              return;\n            }\n\n            for (i = 0; i < node.children.length; i++) {\n              this.setInitialCollapsedBranches(node.children[i]);\n            }\n          }\n          /**\n           * @param {MouseEvent} event\n           * @returns {Branch}\n           */\n\n        }, {\n          key: 'getNodeAtMousePosition',\n          value: function getNodeAtMousePosition(event) {\n            var _root;\n\n            return (_root = this.root).clicked.apply(_root, _toConsumableArray(translateClick(event, this)));\n          }\n          /**\n           * @returns {Branch[]} Selected leaves\n           */\n\n        }, {\n          key: 'getSelectedNodeIds',\n          value: function getSelectedNodeIds() {\n            return this.getNodeIdsWithFlag('selected');\n          }\n          /**\n           * @param {string} flag - A boolean property of the branch\n           * @param {boolean} [value=true]\n           * @returns {Branch[]}\n           */\n\n        }, {\n          key: 'getNodeIdsWithFlag',\n          value: function getNodeIdsWithFlag(flag) {\n            var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return this.leaves.reduce(function (memo, leaf) {\n              if (leaf[flag] === value) {\n                memo.push(leaf.id);\n              }\n\n              return memo;\n            }, []);\n          }\n          /**\n           * Event listener for click events.\n           *\n           * @param {MouseEvent} e\n           */\n\n        }, {\n          key: 'clicked',\n          value: function clicked(e) {\n            var node;\n\n            if (e.button === 0) {\n              var nodeIds = []; // if this is triggered by the release after a drag then the click\n              // shouldn't be triggered.\n\n              if (this.dragging) {\n                this.dragging = false;\n                return;\n              }\n\n              if (!this.root) return false;\n              node = this.getNodeAtMousePosition(e);\n              var isMultiSelectActive = this.multiSelect && (e.metaKey || e.ctrlKey);\n\n              if (node && node.interactive) {\n                if (isMultiSelectActive) {\n                  if (node.leaf) {\n                    node[this.clickFlag] = !node[this.clickFlag];\n                  } else if (this.internalNodesSelectable) {\n                    var someUnflagged = node.getChildProperties(this.clickFlag).some(function (prop) {\n                      return prop === false;\n                    });\n                    node.cascadeFlag(this.clickFlag, someUnflagged, this.clickFlagPredicate);\n                  }\n\n                  nodeIds = this.getNodeIdsWithFlag(this.clickFlag);\n                  this.draw();\n                } else {\n                  this.root.cascadeFlag(this.clickFlag, false, this.clickFlagPredicate);\n\n                  if (this.internalNodesSelectable || node.leaf) {\n                    node.cascadeFlag(this.clickFlag, true, this.clickFlagPredicate);\n                    nodeIds = node.getChildProperties('id');\n                  }\n\n                  this.draw();\n                }\n              } else if (this.unselectOnClickAway && !this.dragging && !isMultiSelectActive) {\n                this.root.cascadeFlag(this.clickFlag, false, this.clickFlagPredicate);\n                this.draw();\n              }\n\n              if (!this.pickedup) {\n                this.dragging = false;\n              }\n\n              this.nodesUpdated(nodeIds, this.clickFlag);\n            }\n          }\n          /**\n           * Handles dragging and hovering.\n           *\n           * @param {MouseEvent} event\n           */\n\n        }, {\n          key: 'drag',\n          value: function drag(event) {\n            // get window ratio\n            var ratio = getPixelRatio(this.canvas);\n            if (!this.drawn) return false;\n\n            if (this.pickedup) {\n              var xmove = (event.clientX - this.startx) * ratio;\n              var ymove = (event.clientY - this.starty) * ratio;\n\n              if (Math.abs(xmove) + Math.abs(ymove) > 5) {\n                this.dragging = true;\n                this.offsetx = this.origx + xmove;\n                this.offsety = this.origy + ymove;\n                this.draw();\n              }\n            } else {\n              // hover\n              var e = event;\n              var nd = this.getNodeAtMousePosition(e);\n\n              if (nd && nd.interactive && (this.internalNodesSelectable || nd.leaf)) {\n                this.root.cascadeFlag('hovered', false);\n                nd.hovered = true; // For mouseover tooltip to show no. of children on the internal nodes\n\n                if (!nd.leaf && !nd.hasCollapsedAncestor()) {\n                  this.tooltip.open(e.clientX, e.clientY, nd);\n                }\n\n                this.containerElement.style.cursor = 'pointer';\n              } else {\n                this.tooltip.close();\n                this.root.cascadeFlag('hovered', false);\n\n                if (this.shiftKeyDrag && e.shiftKey) {\n                  setCursorDrag(this.containerElement);\n                } else {\n                  this.containerElement.style.cursor = 'auto';\n                }\n              }\n\n              this.draw();\n            }\n          }\n          /**\n           * Draws the frame.\n           *\n           * @param {boolean} forceRedraw - Also run the prerenderer.\n           */\n\n        }, {\n          key: 'draw',\n          value: function draw(forceRedraw) {\n            this.highlighters.length = 0;\n\n            if (this.maxBranchLength === 0) {\n              this.loadError(new Error('All branches in the tree are identical.'));\n              return;\n            }\n\n            this.canvas.clearRect(0, 0, this.canvas.canvas.width, this.canvas.canvas.height);\n            this.canvas.lineCap = 'round';\n            this.canvas.lineJoin = 'round';\n            this.canvas.strokeStyle = this.branchColour;\n            this.canvas.save();\n\n            if (!this.drawn || forceRedraw) {\n              this.prerenderer.run(this);\n\n              if (!forceRedraw) {\n                this.fitInPanel();\n              }\n            }\n\n            var pixelRatio = getPixelRatio(this.canvas);\n            this.canvas.lineWidth = this.lineWidth / this.zoom;\n            this.canvas.translate(this.offsetx * pixelRatio, this.offsety * pixelRatio);\n            this.canvas.scale(this.zoom, this.zoom);\n            this.branchRenderer.render(this, this.root);\n            this.highlighters.forEach(function (render) {\n              return render();\n            });\n            this.drawn = true;\n            this.canvas.restore();\n          }\n          /**\n           * Mousedown event listener\n           *\n           * @param {MouseEvent} event\n           */\n\n        }, {\n          key: 'pickup',\n          value: function pickup(event) {\n            if (!this.shiftKeyDrag || event.shiftKey) {\n              if (!this.drawn) return false;\n              this.origx = this.offsetx;\n              this.origy = this.offsety;\n\n              if (event.button === 0) {\n                this.pickedup = true;\n                setCursorDragging(this.containerElement);\n              }\n\n              this.startx = event.clientX;\n              this.starty = event.clientY;\n            }\n          }\n          /**\n           * mouseup event listener.\n           */\n\n        }, {\n          key: 'drop',\n          value: function drop(event) {\n            if (!this.drawn) return false;\n            this.pickedup = false;\n\n            if (this.shiftKeyDrag && event.shiftKey) {\n              setCursorDrag(this.containerElement);\n            } else {\n              this.containerElement.style.cursor = 'auto';\n            }\n          }\n          /**\n           * Mousewheel event listener.\n           *\n           * @param event\n           */\n\n        }, {\n          key: 'scroll',\n          value: function scroll(event) {\n            if (this.disableZoom || 'wheelDelta' in event && event.wheelDelta === 0) {\n              return;\n            }\n\n            event.preventDefault();\n            this._point.x = event.offsetX;\n            this._point.y = event.offsetY;\n            var sign = event.detail < 0 || event.wheelDelta > 0 ? 1 : -1;\n\n            if (this.branchScaling && (event.metaKey || event.ctrlKey)) {\n              this.currentBranchScale *= Math.pow(this.branchScalingStep, sign);\n              this.setBranchScale(this.currentBranchScale, this._point);\n            } else {\n              this.smoothZoom(sign, this._point);\n            }\n          }\n          /**\n           * @param {RegExp} pattern\n           * @param {string} [searchProperty=id].\n           * @return {Branch[]}\n           */\n\n        }, {\n          key: 'findLeaves',\n          value: function findLeaves(pattern) {\n            var searchProperty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';\n            var foundLeaves = [];\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n              for (var _iterator4 = this.leaves[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                var leaf = _step4.value;\n\n                if (leaf[searchProperty] && leaf[searchProperty].match(pattern)) {\n                  foundLeaves.push(leaf);\n                }\n              }\n            } catch (err) {\n              _didIteratorError4 = true;\n              _iteratorError4 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                  _iterator4.return();\n                }\n              } finally {\n                if (_didIteratorError4) {\n                  throw _iteratorError4;\n                }\n              }\n            }\n\n            return foundLeaves;\n          }\n          /**\n           * @param {Branch[]} leaves\n           * @param {string} property\n           * @param {} value\n           *\n           * @fires Tree#updated\n           */\n\n        }, {\n          key: 'updateLeaves',\n          value: function updateLeaves(leaves, property, value) {\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n              for (var _iterator5 = this.leaves[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var leaf = _step5.value;\n                leaf[property] = !value;\n              }\n            } catch (err) {\n              _didIteratorError5 = true;\n              _iteratorError5 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                  _iterator5.return();\n                }\n              } finally {\n                if (_didIteratorError5) {\n                  throw _iteratorError5;\n                }\n              }\n            }\n\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n              for (var _iterator6 = leaves[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                var _leaf = _step6.value;\n                _leaf[property] = value;\n              }\n            } catch (err) {\n              _didIteratorError6 = true;\n              _iteratorError6 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                  _iterator6.return();\n                }\n              } finally {\n                if (_didIteratorError6) {\n                  throw _iteratorError6;\n                }\n              }\n            }\n\n            this.nodesUpdated(leaves.map(function (_) {\n              return _.id;\n            }), property);\n          }\n          /**\n           * Deselects all branches, implicitly calls {@link Tree#draw}.\n           */\n\n        }, {\n          key: 'clearSelect',\n          value: function clearSelect() {\n            this.root.cascadeFlag('selected', false);\n            this.draw();\n          }\n          /**\n           * @returns {string} Base64-encoded data uri of canvas\n           */\n\n        }, {\n          key: 'getPngUrl',\n          value: function getPngUrl() {\n            return this.canvas.canvas.toDataURL();\n          }\n          /**\n           * Loads a serialised representation of a tree, using the first registered\n           * parser that validates the input unless a format is specified.\n           *\n           * @param {string} inputString\n           * @param {Object} [options] - also passed on to the parser.\n           * @param {string} [options.format] - specify the parser to use.\n           * @param {function} [callback] - Called synchronously *after* the first draw.\n           *\n           * @fires Tree#error\n           *\n           * @see Tree#build\n           */\n\n        }, {\n          key: 'load',\n          value: function load(inputString) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var callback = arguments[2];\n            var buildOptions = options;\n            var buildCallback = callback; // allows passing callback as second param\n\n            if (typeof options === 'function') {\n              buildCallback = options;\n              buildOptions = {};\n            }\n\n            if (buildCallback) {\n              buildOptions.callback = buildCallback;\n            }\n\n            if (buildOptions.format) {\n              this.build(inputString, _parsers2.default[buildOptions.format], buildOptions);\n              return;\n            }\n\n            var _iteratorNormalCompletion7 = true;\n            var _didIteratorError7 = false;\n            var _iteratorError7 = undefined;\n\n            try {\n              for (var _iterator7 = Object.keys(_parsers2.default)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                var parserName = _step7.value;\n                var parser = _parsers2.default[parserName];\n\n                if (inputString.match(parser.fileExtension) || inputString.match(parser.validator)) {\n                  this.build(inputString, parser, buildOptions);\n                  return;\n                }\n              }\n            } catch (err) {\n              _didIteratorError7 = true;\n              _iteratorError7 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                  _iterator7.return();\n                }\n              } finally {\n                if (_didIteratorError7) {\n                  throw _iteratorError7;\n                }\n              }\n            }\n\n            var error = new Error('String not recognised as a file or a parseable format string');\n\n            if (buildCallback) {\n              buildCallback(error);\n            }\n\n            this.loadError(error);\n          }\n          /**\n           * Builds the {@link Tree#originalTree} object.\n           */\n\n        }, {\n          key: 'saveOriginalTree',\n          value: function saveOriginalTree() {\n            this.originalTree.branches = this.branches;\n            this.originalTree.leaves = this.leaves;\n            this.originalTree.root = this.root;\n            this.originalTree.branchLengths = {};\n            this.originalTree.parents = {};\n          }\n          /**\n           * Clears the branches and leaves of the instance.\n           */\n\n        }, {\n          key: 'clearState',\n          value: function clearState() {\n            this.root = false;\n            this.leaves = [];\n            this.branches = {};\n            this.drawn = false;\n          }\n          /**\n           * Build {@link Tree#branches} and {@link Tree#leaves} properties.\n           */\n\n        }, {\n          key: 'extractNestedBranches',\n          value: function extractNestedBranches() {\n            this.branches = {};\n            this.leaves = [];\n            this.storeNode(this.root);\n            this.root.extractChildren();\n          }\n          /**\n           * High-level API to organising branches and leaves.\n           *\n           * @fires Tree#error\n           */\n\n        }, {\n          key: 'saveState',\n          value: function saveState() {\n            this.extractNestedBranches();\n            this.root.branchLength = 0;\n            this.maxBranchLength = 0;\n            this.root.setTotalLength();\n\n            if (this.maxBranchLength === 0) {\n              this.loadError(new Error('All branches in the tree are identical.'));\n              return;\n            }\n          }\n          /**\n           * Builds the object model of a tree.\n           *\n           * @param {string} formatString\n           * @param {Parser} parser\n           * @param {Object} options\n           *\n           * @fires Tree#error\n           * @fires Tree#beforeFirstDraw\n           * @fires Tree#loadCompleted\n           */\n\n        }, {\n          key: 'build',\n          value: function build(formatString, parser, options) {\n            var _this2 = this;\n\n            this.originalTree = {};\n            this.clearState();\n            _Branch2.default.lastId = 0;\n            var root = new _Branch2.default();\n            root.id = 'root';\n            this.branches.root = root;\n            this.setRoot(root);\n            parser.parse({\n              formatString: formatString,\n              root: root,\n              options: options\n            }, function (error) {\n              if (error) {\n                if (options.callback) {\n                  options.callback(error);\n                }\n\n                _this2.loadError(error);\n\n                return;\n              }\n\n              _this2.stringRepresentation = formatString;\n\n              _this2.saveState();\n\n              _this2.setInitialCollapsedBranches();\n\n              _this2.beforeFirstDraw();\n\n              _this2.draw();\n\n              _this2.saveOriginalTree();\n\n              if (options.callback) {\n                options.callback();\n              }\n\n              _this2.loadCompleted();\n            });\n          }\n          /**\n           * Draw a subtree.\n           *\n           * @param {Branch} node - the new root of the tree.\n           *\n           * @fires Tree#subtree\n           */\n\n        }, {\n          key: 'redrawFromBranch',\n          value: function redrawFromBranch(node) {\n            this.clearState();\n            this.resetTree();\n            this.originalTree.branchLengths[node.id] = node.branchLength;\n            this.originalTree.parents[node.id] = node.parent;\n            this.root = node;\n            this.root.parent = false;\n            this.saveState();\n            this.draw();\n            this.subtreeDrawn(node.id);\n          }\n          /**\n           * Reload the serialised version of the tree.\n           */\n\n        }, {\n          key: 'redrawOriginalTree',\n          value: function redrawOriginalTree() {\n            this.load(this.stringRepresentation);\n          }\n          /**\n           * Traverse the tree, generating ids and filing away objects.\n           *\n           * @param {Branch} node - starting point.\n           */\n\n        }, {\n          key: 'storeNode',\n          value: function storeNode(node) {\n            if (!node.id || node.id === '') {\n              node.id = _Branch2.default.generateId();\n            }\n\n            if (this.branches[node.id]) {\n              if (node !== this.branches[node.id]) {\n                if (!node.leaf) {\n                  node.id = _Branch2.default.generateId();\n                } else {\n                  throw new Error('Two nodes on this tree share the id ' + node.id);\n                }\n              }\n            }\n\n            this.branches[node.id] = node;\n\n            if (node.leaf) {\n              this.leaves.push(node);\n            }\n          }\n          /**\n           * @param {number} size\n           */\n\n        }, {\n          key: 'setNodeSize',\n          value: function setNodeSize(size) {\n            this.baseNodeSize = Number(size);\n            this.draw();\n          }\n          /**\n           * @param {Branch} node\n           */\n\n        }, {\n          key: 'setRoot',\n          value: function setRoot(node) {\n            node.tree = this;\n            this.root = node;\n          }\n          /**\n           * @param {number|string} size\n           */\n\n        }, {\n          key: 'setTextSize',\n          value: function setTextSize(size) {\n            this.textSize = Number(size);\n            this.draw();\n          }\n          /**\n           * Sets an appropriate font size for the proportions of the tree.\n           *\n           * @param {number} ystep - the space between leaves.\n           */\n\n        }, {\n          key: 'setFontSize',\n          value: function setFontSize(ystep) {\n            this.textSize = this.calculateFontSize ? this.calculateFontSize(ystep) : Math.min(ystep / 2, 15);\n            this.canvas.font = this.textSize + 'pt ' + this.font;\n          }\n          /**\n           * @param {string} type - The name of a registered tree type.\n           * @param {boolean} [quiet] - Do not broadcast.\n           *\n           * @fires Tree#typechanged\n           */\n\n        }, {\n          key: 'setTreeType',\n          value: function setTreeType(type, quiet) {\n            if (!(type in _treeTypes2.default)) {\n              return fireEvent(this.containerElement, 'error', {\n                error: new Error('\"' + type + '\" is not a known tree-type.')\n              });\n            }\n\n            var oldType = this.treeType;\n            this.treeType = type;\n            this.type = _treeTypes2.default[type];\n            this.branchRenderer = _treeTypes2.default[type].branchRenderer;\n            this.prerenderer = _treeTypes2.default[type].prerenderer;\n            this.labelAlign = _treeTypes2.default[type].labelAlign;\n            this.calculateFontSize = _treeTypes2.default[type].calculateFontSize;\n\n            if (this.drawn) {\n              this.drawn = false;\n              this.draw();\n            }\n\n            if (!quiet) {\n              this.treeTypeChanged(oldType, type);\n            }\n          }\n          /**\n           * Resizes the canvas element.\n           *\n           * @param {number} width\n           * @param {number} height\n           */\n\n        }, {\n          key: 'setSize',\n          value: function setSize(width, height) {\n            this.canvas.canvas.width = width;\n            this.canvas.canvas.height = height;\n\n            if (this.navigator) {\n              this.navigator.resize();\n            }\n\n            this.adjustForPixelRatio();\n          }\n          /**\n           * Scale the size of the canvas element to the pixel ratio\n           */\n\n        }, {\n          key: 'adjustForPixelRatio',\n          value: function adjustForPixelRatio() {\n            var ratio = getPixelRatio(this.canvas);\n            this.canvas.canvas.style.height = this.canvas.canvas.height + 'px';\n            this.canvas.canvas.style.width = this.canvas.canvas.width + 'px';\n\n            if (ratio > 1) {\n              this.canvas.canvas.width *= ratio;\n              this.canvas.canvas.height *= ratio;\n            }\n          }\n          /**\n           * @returns {{ x: number, y: number }} point w/ x and y coordinates\n           */\n\n        }, {\n          key: 'getCentrePoint',\n          value: function getCentrePoint() {\n            var pixelRatio = getPixelRatio(this.canvas);\n            return {\n              x: this.canvas.canvas.width / 2 / pixelRatio,\n              y: this.canvas.canvas.height / 2 / pixelRatio\n            };\n          }\n          /**\n           * Zoom to a specific level over a specific point.\n           *\n           * @param {number} zoom\n           * @param {{ x: number, y: number }} [point=Tree#getCentrePoint]\n           */\n\n        }, {\n          key: 'setZoom',\n          value: function setZoom(zoom) {\n            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getCentrePoint(),\n                x = _ref.x,\n                y = _ref.y;\n\n            if (zoom > 0) {\n              var oldZoom = this.zoom;\n              this.zoom = zoom;\n              this.offsetx = this.calculateZoomedOffset(this.offsetx, x, oldZoom, zoom);\n              this.offsety = this.calculateZoomedOffset(this.offsety, y, oldZoom, zoom);\n              this.draw();\n            }\n          }\n          /**\n           * Zoom in or out from the current zoom level towards a point.\n           *\n           * @param {number} steps - positive to zoom in, negative to zoom out.\n           * @param {{ x: number, y: number }} point\n           */\n\n        }, {\n          key: 'smoothZoom',\n          value: function smoothZoom(steps, point) {\n            this.setZoom(Math.pow(10, Math.log(this.zoom) / Math.log(10) + steps * this.zoomFactor * 0.01), point);\n          }\n          /**\n           * Magic to enable zooming to a point.\n           *\n           * @author Khalil Abudahab\n           * @param {number} offset\n           * @param {number} coord\n           * @param {number} oldZoom\n           * @param {number} newZoom\n           */\n\n        }, {\n          key: 'calculateZoomedOffset',\n          value: function calculateZoomedOffset(offset, coord, oldZoom, newZoom) {\n            return -1 * ((-1 * offset + coord) / oldZoom * newZoom - coord);\n          }\n          /**\n           * Scale branches horizontally\n           *\n           * @param {number} scale\n           * @param {Object} point\n           */\n\n        }, {\n          key: 'setBranchScale',\n          value: function setBranchScale() {\n            var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n            var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n              x: this.canvas.canvas.width / 2,\n              y: this.canvas.canvas.height / 2\n            };\n            var treeType = _treeTypes2.default[this.treeType];\n\n            if (!treeType.branchScalingAxis || scale < 0) {\n              return;\n            }\n\n            var previoudBranchLength = this.branchScalar;\n            this.branchScalar = this.initialBranchScalar * scale;\n            var scaleRatio = this.branchScalar / previoudBranchLength;\n            var offset = this['offset' + treeType.branchScalingAxis];\n            var oldPosition = point[treeType.branchScalingAxis];\n            var newPosition = (point[treeType.branchScalingAxis] - offset) * scaleRatio + offset;\n            this['offset' + treeType.branchScalingAxis] += oldPosition - newPosition;\n            this.draw();\n          }\n          /**\n           * @method\n           */\n\n        }, {\n          key: 'toggleLabels',\n          value: function toggleLabels() {\n            this.showLabels = !this.showLabels;\n            this.draw();\n          }\n          /**\n           * @method\n           */\n\n        }, {\n          key: 'setMaxLabelLength',\n          value: function setMaxLabelLength() {\n            var dimensions;\n\n            if (this.maxLabelLength[this.treeType] === undefined) {\n              this.maxLabelLength[this.treeType] = 0;\n            }\n\n            for (var i = 0; i < this.leaves.length; i++) {\n              dimensions = this.canvas.measureText(this.leaves[i].id); // finding the maximum label length\n\n              if (dimensions.width > this.maxLabelLength[this.treeType]) {\n                this.maxLabelLength[this.treeType] = dimensions.width;\n              }\n            }\n          }\n          /**\n           * @event Tree#loading\n           */\n\n        }, {\n          key: 'loadStarted',\n          value: function loadStarted() {\n            fireEvent(this.containerElement, 'loading');\n          }\n          /**\n           * @event Tree#beforeFirstDraw\n           */\n\n        }, {\n          key: 'beforeFirstDraw',\n          value: function beforeFirstDraw() {\n            fireEvent(this.containerElement, 'beforeFirstDraw');\n          }\n          /**\n           * @event Tree#loaded\n           */\n\n        }, {\n          key: 'loadCompleted',\n          value: function loadCompleted() {\n            fireEvent(this.containerElement, 'loaded');\n          }\n          /**\n           * @event Tree#error\n           * @property {Error} error\n           */\n\n        }, {\n          key: 'loadError',\n          value: function loadError(error) {\n            fireEvent(this.containerElement, 'error', {\n              error: error\n            });\n          }\n          /**\n           * @event Tree#subtree\n           * @property {Branch} node\n           */\n\n        }, {\n          key: 'subtreeDrawn',\n          value: function subtreeDrawn(node) {\n            fireEvent(this.containerElement, 'subtree', {\n              node: node\n            });\n          }\n          /**\n           * @event Tree#updated\n           * @property {string[]} nodeIds\n           * @property {string} property\n           * @property {boolean} append\n           */\n\n        }, {\n          key: 'nodesUpdated',\n          value: function nodesUpdated(nodeIds, property) {\n            var append = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            fireEvent(this.containerElement, 'updated', {\n              nodeIds: nodeIds,\n              property: property,\n              append: append\n            });\n          }\n          /**\n           * @event Tree#typechanged\n           * @property {string} oldType\n           * @property {string} newType\n           */\n\n        }, {\n          key: 'treeTypeChanged',\n          value: function treeTypeChanged(oldType, newType) {\n            fireEvent(this.containerElement, 'typechanged', {\n              oldType: oldType,\n              newType: newType\n            });\n          }\n          /**\n           * @param {string}\n           * @param {function}\n           */\n\n        }, {\n          key: 'addListener',\n          value: function addListener(event, listener, target) {\n            if (!this.eventListeners[event]) this.eventListeners[event] = [];\n            this.eventListeners[event].push({\n              listener: listener,\n              target: target\n            });\n            addEvent(target || this.containerElement, event, listener);\n          }\n          /**\n           * @param {string}\n           * @param {function}\n           */\n\n        }, {\n          key: 'removeListener',\n          value: function removeListener(event, listener, target) {\n            removeEvent(target || this.containerElement, event, listener);\n          }\n          /**\n           * @param {Array.<Branch>} [leaves=this.leaves]\n           *\n           * @returns {Array.<Array.<number>>} bounds - Minimum x and y coordinates in\n           * the first array, maximum x and y coordinates in the second.\n           *\n           * @example const [ [ minx, miny ], [ maxx, maxy ] ] = tree.getBounds()\n           */\n\n        }, {\n          key: 'getBounds',\n          value: function getBounds() {\n            var leaves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.leaves; // this.leaves assumes bounds of whole tree, start from root\n\n            var initialBounds = leaves === this.leaves ? this.root : leaves[0];\n            var minx = initialBounds.startx;\n            var maxx = initialBounds.startx;\n            var miny = initialBounds.starty;\n            var maxy = initialBounds.starty;\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n            var _iteratorError8 = undefined;\n\n            try {\n              for (var _iterator8 = leaves[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                var leaf = _step8.value;\n                var bounds = leaf.getBounds();\n                minx = Math.min(minx, bounds.minx);\n                maxx = Math.max(maxx, bounds.maxx);\n                miny = Math.min(miny, bounds.miny);\n                maxy = Math.max(maxy, bounds.maxy);\n              }\n            } catch (err) {\n              _didIteratorError8 = true;\n              _iteratorError8 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                  _iterator8.return();\n                }\n              } finally {\n                if (_didIteratorError8) {\n                  throw _iteratorError8;\n                }\n              }\n            }\n\n            return [[minx, miny], [maxx, maxy]];\n          }\n          /**\n           * Zoom to the provided leaves.\n           *\n           * @param {Array.<Branch>}\n           */\n\n        }, {\n          key: 'fitInPanel',\n          value: function fitInPanel(leaves) {\n            this.zoom = 1; // calculates consistent bounds\n\n            var bounds = this.getBounds(leaves);\n            var canvasSize = [this.canvas.canvas.width - this.padding * 2, this.canvas.canvas.height - this.padding * 2];\n            var treeSize = [bounds[1][0] - bounds[0][0], bounds[1][1] - bounds[0][1]];\n            var pixelRatio = getPixelRatio(this.canvas);\n            var xZoomRatio = canvasSize[0] / treeSize[0];\n            var yZoomRatio = canvasSize[1] / treeSize[1];\n            this.zoom = Math.min(xZoomRatio, yZoomRatio);\n            this.offsetx = -1 * bounds[0][0] * this.zoom;\n            this.offsety = -1 * bounds[0][1] * this.zoom;\n\n            if (xZoomRatio > yZoomRatio) {\n              this.offsetx += this.padding + (canvasSize[0] - treeSize[0] * this.zoom) / 2;\n              this.offsety += this.padding;\n            } else {\n              this.offsetx += this.padding;\n              this.offsety += this.padding + (canvasSize[1] - treeSize[1] * this.zoom) / 2;\n            }\n\n            this.offsetx = this.offsetx / pixelRatio;\n            this.offsety = this.offsety / pixelRatio;\n          }\n          /**\n           * Reapply data in {@link Tree#originalTree}.\n           */\n\n        }, {\n          key: 'resetTree',\n          value: function resetTree() {\n            if (!this.originalTree.branches) return;\n            this.branches = this.originalTree.branches;\n            var _iteratorNormalCompletion9 = true;\n            var _didIteratorError9 = false;\n            var _iteratorError9 = undefined;\n\n            try {\n              for (var _iterator9 = Object.keys(this.originalTree.branchLengths)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                var n = _step9.value;\n                this.branches[n].branchLength = this.originalTree.branchLengths[n];\n                this.branches[n].parent = this.originalTree.parents[n];\n              }\n            } catch (err) {\n              _didIteratorError9 = true;\n              _iteratorError9 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                  _iterator9.return();\n                }\n              } finally {\n                if (_didIteratorError9) {\n                  throw _iteratorError9;\n                }\n              }\n            }\n\n            this.leaves = this.originalTree.leaves;\n            this.root = this.originalTree.root;\n          }\n          /**\n           * @param {Branch}\n           */\n\n        }, {\n          key: 'rotateBranch',\n          value: function rotateBranch(branch) {\n            this.branches[branch.id].rotate();\n          }\n          /**\n           * @returns {string} Newick representation of current object model.\n           */\n\n        }, {\n          key: 'exportNwk',\n          value: function exportNwk() {\n            var nwk = this.root.getNwk();\n            return nwk.substr(0, nwk.lastIndexOf(')') + 1) + ';';\n          }\n          /**\n           * Resize canvas element to container.\n           */\n\n        }, {\n          key: 'resizeToContainer',\n          value: function resizeToContainer() {\n            this.setSize(this.containerElement.offsetWidth, this.containerElement.offsetHeight);\n          }\n          /**\n           * Removes tracked event listeners and provides a hook for plugins to clean up\n           * after themselves.\n           */\n\n        }, {\n          key: 'cleanup',\n          value: function cleanup() {\n            this.removeEventListeners();\n          }\n        }, {\n          key: 'alignLabels',\n          get: function get() {\n            return this.showLabels && this.labelAlign && this.labelAlignEnabled;\n          },\n          set: function set(value) {\n            this.labelAlignEnabled = value;\n          }\n        }]);\n\n        return Tree;\n      }();\n      /**\n       * @memberof Tree\n       * @method\n       * @see Tree#addListener\n       */\n\n\n      Tree.prototype.on = Tree.prototype.addListener;\n      /**\n       * @memberof Tree\n       * @method\n       * @see Tree#removeListener\n       */\n\n      Tree.prototype.off = Tree.prototype.removeListener;\n      exports.default = Tree;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.events = exports.dom = exports.constants = exports.canvas = undefined;\n\n      var _canvas2 = __webpack_require__(3);\n\n      var _canvas = _interopRequireWildcard(_canvas2);\n\n      var _constants2 = __webpack_require__(6);\n\n      var _constants = _interopRequireWildcard(_constants2);\n\n      var _dom2 = __webpack_require__(4);\n\n      var _dom = _interopRequireWildcard(_dom2);\n\n      var _events2 = __webpack_require__(5);\n\n      var _events = _interopRequireWildcard(_events2);\n\n      function _interopRequireWildcard(obj) {\n        if (obj && obj.__esModule) {\n          return obj;\n        } else {\n          var newObj = {};\n\n          if (obj != null) {\n            for (var key in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n            }\n          }\n\n          newObj.default = obj;\n          return newObj;\n        }\n      }\n\n      exports.canvas = _canvas;\n      exports.constants = _constants;\n      exports.dom = _dom;\n      exports.events = _events;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.getBackingStorePixelRatio = getBackingStorePixelRatio;\n      exports.getPixelRatio = getPixelRatio;\n      exports.translateClick = translateClick;\n      exports.translatePoint = translatePoint;\n      exports.undoPointTranslation = undoPointTranslation;\n\n      var _dom = __webpack_require__(4);\n      /**\n       * Return backing store pixel ratio of context.\n       *\n       * @param context - The rendering context of HTMl5 canvas.\n       *\n       */\n\n\n      function getBackingStorePixelRatio(context) {\n        return context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;\n      }\n\n      function getPixelRatio(canvas) {\n        return (window.devicePixelRatio || 1) / getBackingStorePixelRatio(canvas);\n      }\n\n      function translateClick(event, tree) {\n        var pixelRatio = getPixelRatio(tree.canvas);\n        return [(event.offsetX - tree.offsetx) / tree.zoom * pixelRatio, (event.offsetY - tree.offsety) / tree.zoom * pixelRatio];\n      }\n\n      function translatePoint() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n          x: 0,\n          y: 0\n        },\n            x = _ref.x,\n            y = _ref.y;\n\n        var phylocanvas = arguments[1];\n        var pixelRatio = getPixelRatio(phylocanvas.canvas);\n        return {\n          x: (x - phylocanvas.offsetx) / phylocanvas.zoom * pixelRatio,\n          y: (y - phylocanvas.offsety) / phylocanvas.zoom * pixelRatio\n        };\n      }\n\n      function undoPointTranslation() {\n        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n          x: 0,\n          y: 0\n        },\n            x = _ref2.x,\n            y = _ref2.y;\n\n        var phylocanvas = arguments[1];\n        var pixelRatio = getPixelRatio(phylocanvas.canvas);\n        return {\n          x: x / pixelRatio * phylocanvas.zoom + phylocanvas.offsetx,\n          y: y / pixelRatio * phylocanvas.zoom + phylocanvas.offsety\n        };\n      }\n      /***/\n\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.createBlobUrl = createBlobUrl;\n      exports.setupDownloadLink = setupDownloadLink;\n      exports.getX = getX;\n      exports.getY = getY;\n      exports.addClass = addClass;\n      exports.removeClass = removeClass;\n      exports.hasClass = hasClass;\n      exports.setCursorDragging = setCursorDragging;\n      exports.setCursorDrag = setCursorDrag;\n\n      var _events = __webpack_require__(5);\n\n      var windowURL = window.URL || window.webkitURL;\n\n      function createBlobUrl(data) {\n        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text/plain;charset=utf-8';\n        var blob = new Blob([data], {\n          type: type\n        });\n        return windowURL.createObjectURL(blob);\n      }\n\n      function setupDownloadLink(url, filename) {\n        var anchor = document.createElement('a');\n        var isDownloadSupported = typeof anchor.download !== 'undefined';\n        anchor.href = url;\n        anchor.target = '_blank';\n\n        if (isDownloadSupported) {\n          anchor.download = filename;\n        }\n\n        (0, _events.fireEvent)(anchor, 'click');\n\n        if (isDownloadSupported) {\n          windowURL.revokeObjectURL(anchor.href);\n        }\n      }\n      /**\n       * Get the x coordinate of oElement\n       *\n       * @param domElement - The element to get the X position of.\n       *\n       */\n\n\n      function getX(domElement) {\n        var xValue = 0;\n\n        while (domElement) {\n          xValue += domElement.offsetLeft;\n          domElement = domElement.offsetParent;\n        }\n\n        return xValue;\n      }\n      /**\n       * Get the y coordinate of oElement\n       *\n       * @param domElement - The element to get the Y position of.\n       *\n       */\n\n\n      function getY(domElement) {\n        var yValue = 0;\n\n        while (domElement) {\n          yValue += domElement.offsetTop;\n          domElement = domElement.offsetParent;\n        }\n\n        return yValue;\n      }\n\n      function addClass(element, className) {\n        var classes = element.className.split(' ');\n\n        if (classes.indexOf(className) === -1) {\n          classes.push(className);\n          element.className = classes.join(' ');\n        }\n      }\n\n      function removeClass(element, className) {\n        var classes = element.className.split(' ');\n        var index = classes.indexOf(className);\n\n        if (index !== -1) {\n          classes.splice(index, 1);\n          element.className = classes.join(' ');\n        }\n      }\n\n      function hasClass(element, className) {\n        var classes = element.className.split(' ');\n        var index = classes.indexOf(className);\n        return index !== -1;\n      }\n      /**\n       * Setting the cursor to dragging required vendor prefixes.\n       * @param domElement\n       */\n\n\n      function setCursorDragging(domElement) {\n        domElement.style.cursor = \"-webkit-grabbing\";\n        domElement.style.cursor = \"-moz-grabbing\";\n        domElement.style.cursor = \"grabbing\";\n      }\n      /**\n       * Setting the cursor to drag required vendor prefixes.\n       * @param domElement\n       */\n\n\n      function setCursorDrag(domElement) {\n        domElement.style.cursor = \"-webkit-grab\";\n        domElement.style.cursor = \"-moz-grab\";\n        domElement.style.cursor = \"grab\";\n      }\n      /***/\n\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      exports.preventDefault = preventDefault;\n      exports.fireEvent = fireEvent;\n      exports.addEvent = addEvent;\n      exports.removeEvent = removeEvent;\n      exports.killEvent = killEvent;\n      exports.createHandler = createHandler;\n\n      function preventDefault(event) {\n        event.preventDefault();\n        return false;\n      }\n\n      function fireEvent(element, type) {\n        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var event; // The custom event that will be created\n\n        var param;\n\n        if (document.createEvent) {\n          event = document.createEvent('HTMLEvents');\n          event.initEvent(type, true, true);\n        } else {\n          event = document.createEventObject();\n          event.eventType = type;\n        }\n\n        event.eventName = type;\n\n        for (param in params) {\n          if (params.hasOwnProperty(param)) {\n            event[param] = params[param];\n          }\n        }\n\n        if (document.createEvent) {\n          element.dispatchEvent(event);\n        } else {\n          element.fireEvent('on' + event.eventType, event);\n        }\n      }\n\n      function addEvent(elem, event, fn) {\n        if (elem.addEventListener) {\n          elem.addEventListener(event, fn, false);\n        } else {\n          elem.attachEvent('on' + event, function () {\n            // set the this pointer same as addEventListener when fn is called\n            return fn.call(elem, window.event);\n          });\n        }\n      }\n\n      function removeEvent(elem, event, fn) {\n        if (elem.removeEventListener) {\n          elem.removeEventListener(event, fn, false);\n        } else {\n          console.warn('[Phylocanvas] Unable to remove event, removeEventListener not supported');\n        }\n      }\n\n      function killEvent(e) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n      /**\n       * Creates a function which can be called from an event handler independent of\n       * scope.\n       *\n       * @param {Object} obj the object the function will be called on\n       * @param {String} func the name of the function to be called\n       * @retuns {function}\n       */\n\n\n      function createHandler(obj, func) {\n        var handler;\n\n        if ((typeof func === 'undefined' ? 'undefined' : _typeof(func)) === _typeof('aaa')) {\n          handler = function handler(e) {\n            if (obj[func]) {\n              return obj[func](e);\n            }\n          };\n        } else {\n          handler = function handler() {\n            return func(obj);\n          };\n        }\n\n        return handler;\n      }\n      /***/\n\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      /**\n       * An enumeration of certain pre-defined angles to enable faster drawing of\n       * trees. There are FORTYFIVE, QUARTER, HALF and FULL. Values are all radians.\n       *\n       * @enum\n       * @memberof PhyloCanvas\n       * @constant\n       */\n\n      var Angles = exports.Angles = {\n        /**\n         * @constant\n         * @type double\n         * @description PI / 4\n         */\n        FORTYFIVE: Math.PI / 4,\n\n        /**\n         * @constant\n         * @type double\n         * @description PI / 2\n         */\n        QUARTER: Math.PI / 2,\n\n        /**\n         * @constant\n         * @type double\n         * @description PI\n         */\n        HALF: Math.PI,\n\n        /**\n         * @constant\n         * @type double\n         * @description PI * 2\n         */\n        FULL: 2 * Math.PI\n      };\n      /**\n       * dictionary to translate newick annotations to branch renderer ids\n       *\n       * @enum\n       * @memberof PhyloCanvas\n       * @constant\n       */\n\n      var Shapes = exports.Shapes = {\n        x: 'star',\n        s: 'square',\n        o: 'circle',\n        t: 'triangle'\n      };\n      /**\n       * Standard set of predicates.\n       *\n       * @enum\n       * @constant\n       */\n\n      var Predicates = exports.Predicates = {\n        tautology: function tautology() {\n          return true;\n        },\n        contradiction: function contradiction() {\n          return false;\n        },\n        leafOnly: function leafOnly(node) {\n          return node.leaf;\n        },\n        nonLeaf: function nonLeaf(node) {\n          return !node.leaf;\n        }\n      };\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _utils = __webpack_require__(2);\n\n      var _treeTypes = __webpack_require__(8);\n\n      var _treeTypes2 = _interopRequireDefault(_treeTypes);\n\n      var _nodeRenderers = __webpack_require__(26);\n\n      var _nodeRenderers2 = _interopRequireDefault(_nodeRenderers);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var Angles = _utils.constants.Angles,\n          Shapes = _utils.constants.Shapes; // Caching object to reduce garbage\n\n      var _bounds = {\n        minx: 0,\n        maxx: 0,\n        miny: 0,\n        maxy: 0\n      };\n      var _leafStyle = {\n        lineWidth: null,\n        strokeStyle: null,\n        fillStyle: null\n      };\n      /**\n       * A branch of the tree.\n       *\n       * @class\n       */\n\n      var Branch = function () {\n        function Branch() {\n          _classCallCheck(this, Branch);\n          /**\n           * The branch's angle clockwise from horizontal in radians (used paricularly\n           * for circular and radial trees).\n           *\n           * @type number\n           */\n\n\n          this.angle = 0;\n          /**\n           * The length of the branch.\n           *\n           * @type number\n           */\n\n          this.branchLength = 0;\n          /**\n           * The center of the end of the node on the x axis.\n           *\n           * @type number\n           */\n\n          this.centerx = 0;\n          /**\n           * The center of the end of the node on the y axis.\n           *\n           * @type number\n           */\n\n          this.centery = 0;\n          /**\n           * The branches that stem from this branch.\n           *\n           * @type Branch[]\n           */\n\n          this.children = [];\n          /**\n           * True if the node has been collapsed.\n           *\n           * @type boolean\n           * @default\n           */\n\n          this.collapsed = false;\n          /**\n           * Custom colour for branch, initialised as null to use tree-level default.\n           *\n           * @type string\n           */\n\n          this.colour = null;\n          /**\n           * Holds custom data for this node.\n           *\n           * @type object\n           */\n\n          this.data = {};\n          /**\n           * This node's highlight status.\n           *\n           * @type boolean\n           * @default\n           */\n\n          this.highlighted = false;\n          /**\n           * Whether the user is hovering over the node.\n           *\n           * @type boolean\n           */\n\n          this.hovered = false;\n          /**\n           * This node's unique ID.\n           *\n           * @type string\n           */\n\n          this.id = '';\n          /**\n           * The text label for this node.\n           *\n           * @type string\n           */\n\n          this.label = null;\n          /**\n           * If true, this node has no children.\n           *\n           * @type boolean\n           * @default\n           */\n\n          this.leaf = true;\n          /**\n           * The angle that the last child of this brach 'splays' at, used for\n           * circular trees.\n           *\n           * @type number\n           * @default\n           */\n\n          this.maxChildAngle = 0;\n          /**\n           * The angle that the last child of this brach 'splays' at, used for\n           * circular trees.\n           *\n           * @type number\n           * @default\n           */\n\n          this.minChildAngle = Angles.FULL;\n          /**\n           * What kind of teminal should be drawn on this node.\n           *\n           * @type string\n           * @default\n           */\n\n          this.nodeShape = 'circle';\n          /**\n           * The parent branch of this branch.\n           *\n           * @type Branch\n           */\n\n          this.parent = null;\n          /**\n           * The relative size of the terminal of this node.\n           *\n           * @type number\n           * @default\n           */\n\n          this.radius = 1.0;\n          /**\n           * True if this branch is currently selected.\n           *\n           * @type boolean\n           */\n\n          this.selected = false;\n          /**\n           * The x position of the start of the branch.\n           *\n           * @type number\n           */\n\n          this.startx = 0;\n          /**\n           * The y position of the start of the branch.\n           *\n           * @type number\n           */\n\n          this.starty = 0;\n          /**\n           * The length from the root of the tree to the tip of this branch.\n           *\n           * @type number\n           */\n\n          this.totalBranchLength = 0;\n          /**\n           * The tree object that this branch is part of.\n           *\n           * @type Tree\n           */\n\n          this.tree = null;\n          /**\n           * If true, this branch is not rendered.\n           *\n           * @type boolean\n           * @default\n           */\n\n          this.pruned = false;\n          /**\n           * Allows label to be individually styled.\n           *\n           * @type object\n           * @property {string} colour\n           * @property {number} textSize\n           * @property {string} font\n           * @property {string} format - e.g. bold, italic\n           */\n\n          this.labelStyle = {};\n          /**\n           * Allows label to be individually styled.\n           *\n           * @type object\n           * @property {string} colour\n           * @property {number} textSize\n           * @property {string} font\n           * @property {string} format - e.g. bold, italic\n           */\n\n          this.internalLabelStyle = null;\n          /**\n           * If false, branch does not respond to mouse events.\n           *\n           * @type boolean\n           * @default\n           */\n\n          this.interactive = true;\n          /**\n           * Defines leaf style for this branch.\n           *\n           * @type object\n           * @property {number} lineWidth\n           * @property {string} strokeStyle\n           * @property {string} fillStyle\n           *\n           * @example\n           * branch.leafStyle = {\n           *   lineWidth: 2,\n           *   strokeStyle: '#ff0000',\n           *   fillStyle: 'blue'\n           * };\n           */\n\n          this.leafStyle = {};\n          /**\n           * Minimum x coordintate.\n           *\n           * @type number\n           */\n\n          this.minx = 0;\n          /**\n           * Minimum y coordintate.\n           *\n           * @type number\n           */\n\n          this.miny = 0;\n          /**\n           * Maximum x coordintate.\n           *\n           * @type number\n           */\n\n          this.maxx = 0;\n          /**\n           * Maximum y coordintate.\n           *\n           * @type number\n           */\n\n          this.maxy = 0;\n        }\n        /**\n         * For branches without a label.\n         *\n         * @returns {string} new ID\n         */\n\n\n        _createClass(Branch, [{\n          key: 'clicked',\n\n          /**\n           * Determines if this branch has been clicked.\n           *\n           * @param {number}\n           * @param {number}\n           * @returns {Branch}\n           */\n          value: function clicked(x, y) {\n            if (this.dragging || this.hasCollapsedAncestor()) {\n              return null;\n            }\n\n            if (x < this.maxx && x > this.minx && y < this.maxy && y > this.miny) {\n              return this;\n            }\n\n            for (var i = this.children.length - 1; i >= 0; i--) {\n              var child = this.children[i].clicked(x, y);\n\n              if (child) {\n                return child;\n              }\n            }\n          }\n          /**\n           * @method\n           */\n\n        }, {\n          key: 'drawLabel',\n          value: function drawLabel() {\n            var fSize = this.getTextSize();\n            var label = this.getLabel();\n            this.canvas.font = this.getFontString();\n            this.labelWidth = this.canvas.measureText(label).width; // finding the maximum label length\n\n            if (this.tree.maxLabelLength[this.tree.treeType] === undefined) {\n              this.tree.maxLabelLength[this.tree.treeType] = 0;\n            }\n\n            if (this.labelWidth > this.tree.maxLabelLength[this.tree.treeType]) {\n              this.tree.maxLabelLength[this.tree.treeType] = this.labelWidth;\n            }\n\n            var tx = this.getLabelStartX();\n\n            if (this.tree.alignLabels) {\n              tx += Math.abs(this.tree.labelAlign.getLabelOffset(this));\n            }\n\n            if (this.angle > Angles.QUARTER && this.angle < Angles.HALF + Angles.QUARTER) {\n              this.canvas.rotate(Angles.HALF); // Angles.Half text position changes\n\n              tx = -tx - this.labelWidth * 1;\n            }\n\n            this.canvas.beginPath();\n            this.canvas.fillStyle = this.getTextColour();\n            this.canvas.fillText(label, tx, fSize / 2);\n            this.canvas.closePath(); // Rotate canvas back to original position\n\n            if (this.angle > Angles.QUARTER && this.angle < Angles.HALF + Angles.QUARTER) {\n              this.canvas.rotate(Angles.HALF);\n            }\n          }\n          /**\n           * Sets the minimum and maximum coordinates of the branch.\n           *\n           * @param {number}\n           * @param {number}\n           * @param {number}\n           */\n\n        }, {\n          key: 'setNodeDimensions',\n          value: function setNodeDimensions(centerX, centerY, radius) {\n            var boundedRadius = radius;\n\n            if (radius * this.tree.zoom < 5 || !this.leaf) {\n              boundedRadius = 5 / this.tree.zoom;\n            }\n\n            this.minx = centerX - boundedRadius;\n            this.maxx = centerX + boundedRadius;\n            this.miny = centerY - boundedRadius;\n            this.maxy = centerY + boundedRadius;\n          }\n        }, {\n          key: 'getNumberOfLeaves',\n          value: function getNumberOfLeaves() {\n            var numberOfLeaves = 0;\n            var queue = [this];\n\n            while (queue.length) {\n              var node = queue.pop();\n\n              if (node.leaf) {\n                numberOfLeaves++;\n              } else {\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                  for (var _iterator = node.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var child = _step.value;\n                    queue.push(child);\n                  }\n                } catch (err) {\n                  _didIteratorError = true;\n                  _iteratorError = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                      _iterator.return();\n                    }\n                  } finally {\n                    if (_didIteratorError) {\n                      throw _iteratorError;\n                    }\n                  }\n                }\n              }\n            }\n\n            return numberOfLeaves;\n          }\n          /**\n           * Draws the \"collapsed tip\".\n           *\n           * @param {number}\n           * @param {number}\n           */\n\n        }, {\n          key: 'drawCollapsed',\n          value: function drawCollapsed(centerX, centerY) {\n            var getCollapsedMeasurements = _treeTypes2.default[this.tree.treeType].getCollapsedMeasurements;\n            this.canvas.beginPath();\n\n            var _getCollapsedMeasurem = getCollapsedMeasurements(this),\n                angle = _getCollapsedMeasurem.angle,\n                radius = _getCollapsedMeasurem.radius;\n\n            var startAngle = this.angle - angle / 2;\n            var endAngle = this.angle + angle / 2;\n            this.canvas.moveTo(centerX, centerY);\n            this.canvas.arc(centerX, centerY, radius, startAngle, endAngle, false);\n            var gradient = this.canvas.createRadialGradient(centerX, centerY, radius, centerX, centerY, 0.2 * radius);\n            gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');\n            gradient.addColorStop(1, this.tree.collapsedColour || this.getColour());\n            this.canvas.fillStyle = gradient;\n            this.canvas.fill();\n            this.canvas.closePath();\n          }\n          /**\n           * For aligned labels.\n           *\n           * @method\n           */\n\n        }, {\n          key: 'drawLabelConnector',\n          value: function drawLabelConnector() {\n            var _tree = this.tree,\n                highlightColour = _tree.highlightColour,\n                labelAlign = _tree.labelAlign;\n            this.canvas.save();\n            this.canvas.lineWidth = this.canvas.lineWidth / 4;\n            this.canvas.strokeStyle = this.isHighlighted ? highlightColour : this.getColour();\n            this.canvas.beginPath();\n            this.canvas.moveTo(this.getRadius(), 0);\n            this.canvas.lineTo(labelAlign.getLabelOffset(this) + this.getDiameter(), 0);\n            this.canvas.stroke();\n            this.canvas.closePath();\n            this.canvas.restore();\n          }\n          /**\n           * @method\n           */\n\n        }, {\n          key: 'drawLeaf',\n          value: function drawLeaf() {\n            var _tree2 = this.tree,\n                alignLabels = _tree2.alignLabels,\n                canvas = _tree2.canvas;\n\n            if (alignLabels) {\n              this.drawLabelConnector();\n            }\n\n            canvas.save();\n\n            _nodeRenderers2.default[this.nodeShape](canvas, this.getRadius(), this.getLeafStyle());\n\n            canvas.restore();\n\n            if (this.tree.showLabels || this.tree.hoverLabel && this.isHighlighted) {\n              this.drawLabel();\n            }\n          }\n          /**\n           * @param {number}\n           * @param {number}\n           */\n\n        }, {\n          key: 'drawHighlight',\n          value: function drawHighlight(centerX, centerY) {\n            this.canvas.save();\n            this.canvas.beginPath();\n            this.canvas.strokeStyle = this.tree.highlightColour;\n            this.canvas.lineWidth = this.getHighlightLineWidth();\n            var radius = this.getHighlightRadius();\n            this.canvas.arc(centerX, centerY, radius, 0, Angles.FULL, false);\n            this.canvas.stroke();\n            this.canvas.closePath();\n            this.canvas.restore();\n          }\n          /**\n           * @method\n           */\n\n        }, {\n          key: 'drawBranchLabels',\n          value: function drawBranchLabels() {\n            this.canvas.save();\n            var labelStyle = this.internalLabelStyle || this.tree.internalLabelStyle;\n            this.canvas.fillStyle = labelStyle.colour;\n            this.canvas.font = labelStyle.format + ' ' + labelStyle.textSize + 'pt ' + labelStyle.font;\n            this.canvas.textBaseline = 'middle';\n            this.canvas.textAlign = 'center';\n            var em = this.canvas.measureText('M').width * 2 / 3;\n            var x = this.tree.type.branchScalingAxis === 'y' ? this.centerx : (this.startx + this.centerx) / 2;\n            var y = this.tree.type.branchScalingAxis === 'x' ? this.centery : (this.starty + this.centery) / 2;\n\n            if (this.tree.showBranchLengthLabels && this.tree.branchLengthLabelPredicate(this)) {\n              this.canvas.fillText(this.branchLength.toFixed(2), x, y + em);\n            }\n\n            if (this.tree.showInternalNodeLabels && !this.leaf && this.label) {\n              this.canvas.fillText(this.label, x, y - em);\n            }\n\n            this.canvas.restore();\n          }\n          /**\n           * Draws the line of the branch.\n           */\n\n        }, {\n          key: 'drawNode',\n          value: function drawNode() {\n            var nodeRadius = this.getRadius();\n            /**\n             * theta = translation to center of node... ensures that the node edge is\n             * at the end of the branch so the branches don't look shorter than  they\n             * should\n             */\n\n            var theta = nodeRadius;\n            var centerX = this.leaf ? theta * Math.cos(this.angle) + this.centerx : this.centerx;\n            var centerY = this.leaf ? theta * Math.sin(this.angle) + this.centery : this.centery;\n            this.setNodeDimensions(centerX, centerY, nodeRadius);\n\n            if (this.collapsed) {\n              this.drawCollapsed(centerX, centerY);\n            } else if (this.leaf) {\n              this.canvas.save();\n              this.canvas.translate(this.centerx, this.centery);\n              this.canvas.rotate(this.angle);\n              this.drawLeaf();\n              this.canvas.restore();\n            }\n\n            if (this.isHighlighted) {\n              this.tree.highlighters.push(this.drawHighlight.bind(this, centerX, centerY));\n            }\n\n            if (this.tree.root !== this && this.tree.showBranchLengthLabels || this.tree.showInternalNodeLabels) {\n              this.drawBranchLabels();\n            }\n          }\n          /**\n           * Get property values of leaves under this branch.\n           *\n           * @param {string} - property name\n           * @returns {string[]}\n           */\n\n        }, {\n          key: 'getChildProperties',\n          value: function getChildProperties(property) {\n            if (this.leaf) {\n              // Fix for Issue #68\n              // Returning array, as expected\n              return [this[property]];\n            }\n\n            var children = [];\n\n            for (var x = 0; x < this.children.length; x++) {\n              children = children.concat(this.children[x].getChildProperties(property));\n            }\n\n            return children;\n          }\n          /**\n           * @returns {number}\n           */\n\n        }, {\n          key: 'getChildCount',\n          value: function getChildCount() {\n            if (this.leaf) return 1;\n            var children = 0;\n\n            for (var x = 0; x < this.children.length; x++) {\n              children += this.children[x].getChildCount();\n            }\n\n            return children;\n          }\n          /**\n           * @returns {number}\n           */\n\n        }, {\n          key: 'getChildYTotal',\n          value: function getChildYTotal() {\n            if (this.leaf) return this.centery;\n            var y = 0;\n\n            for (var i = 0; i < this.children.length; i++) {\n              y += this.children[i].getChildYTotal();\n            }\n\n            return y;\n          }\n          /**\n           * Set a boolean property of this branch and its descendants.\n           *\n           * @param {string}\n           * @param {boolean}\n           * @param {function=}\n           */\n\n        }, {\n          key: 'cascadeFlag',\n          value: function cascadeFlag(property, value, predicate) {\n            if (typeof this[property] === 'undefined') {\n              throw new Error('Unknown property: ' + property);\n            }\n\n            if (typeof predicate === 'undefined' || predicate(this, property, value)) {\n              this[property] = value;\n            }\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = this.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var child = _step2.value;\n                child.cascadeFlag(property, value, predicate);\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          }\n          /**\n           * Resets the coordinates and angle of this branch and its descendants.\n           */\n\n        }, {\n          key: 'reset',\n          value: function reset() {\n            var child;\n            var i;\n            this.startx = 0;\n            this.starty = 0;\n            this.centerx = 0;\n            this.centery = 0;\n            this.angle = null; // this.totalBranchLength = 0;\n\n            this.minChildAngle = Angles.FULL;\n            this.maxChildAngle = 0;\n\n            for (i = 0; i < this.children.length; i++) {\n              try {\n                this.children[child].reset();\n              } catch (e) {\n                return e;\n              }\n            }\n          }\n          /**\n           * Set this branch to be the root.\n           */\n\n        }, {\n          key: 'redrawTreeFromBranch',\n          value: function redrawTreeFromBranch() {\n            if (this.collapsed) {\n              this.expand();\n            }\n\n            this.tree.redrawFromBranch(this);\n          }\n          /**\n           * Store this branch's children.\n           */\n\n        }, {\n          key: 'extractChildren',\n          value: function extractChildren() {\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n              for (var _iterator3 = this.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var child = _step3.value;\n                this.tree.storeNode(child);\n                child.extractChildren();\n              }\n            } catch (err) {\n              _didIteratorError3 = true;\n              _iteratorError3 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                  _iterator3.return();\n                }\n              } finally {\n                if (_didIteratorError3) {\n                  throw _iteratorError3;\n                }\n              }\n            }\n          }\n          /**\n           * Walks up the tree looking for a collapsed branch.\n           *\n           * @returns {boolean}\n           */\n\n        }, {\n          key: 'hasCollapsedAncestor',\n          value: function hasCollapsedAncestor() {\n            if (this.parent) {\n              return this.parent.collapsed || this.parent.hasCollapsedAncestor();\n            }\n\n            return false;\n          }\n          /**\n           * @method\n           */\n\n        }, {\n          key: 'collapse',\n          value: function collapse() {\n            // don't collapse the node if it is a leaf... that would be silly!\n            this.collapsed = this.leaf === false;\n          }\n          /**\n           * @method\n           */\n\n        }, {\n          key: 'expand',\n          value: function expand() {\n            this.collapsed = false;\n          }\n          /**\n           * @method\n           */\n\n        }, {\n          key: 'toggleCollapsed',\n          value: function toggleCollapsed() {\n            if (this.collapsed) {\n              this.expand();\n            } else {\n              this.collapse();\n            }\n          }\n          /**\n           * Sums the length of all branches from this one back to the root.\n           */\n\n        }, {\n          key: 'setTotalLength',\n          value: function setTotalLength() {\n            var c;\n\n            if (this.parent) {\n              this.totalBranchLength = this.parent.totalBranchLength + this.branchLength;\n\n              if (this.totalBranchLength > this.tree.maxBranchLength) {\n                this.tree.maxBranchLength = this.totalBranchLength;\n              }\n            } else {\n              this.totalBranchLength = this.branchLength;\n              this.tree.maxBranchLength = this.totalBranchLength;\n            }\n\n            for (c = 0; c < this.children.length; c++) {\n              this.children[c].setTotalLength();\n            }\n          }\n          /**\n           * Add a child branch to this branch.\n           *\n           * @param node {Branch} the node to add as a child\n           */\n\n        }, {\n          key: 'addChild',\n          value: function addChild(node) {\n            node.parent = this;\n            node.tree = this.tree;\n            this.leaf = false;\n            this.children.push(node);\n          }\n          /**\n           * Return the node colour of all the nodes that are children of this one.\n           *\n           * @returns {string[]}\n           */\n\n        }, {\n          key: 'getChildColours',\n          value: function getChildColours() {\n            var colours = [];\n            this.children.forEach(function (branch) {\n              var colour = branch.children.length === 0 ? branch.colour : branch.getColour(); // only add each colour once.\n\n              if (colours.indexOf(colour) === -1) {\n                colours.push(colour);\n              }\n            });\n            return colours;\n          }\n          /**\n           * Get the colour(s) of the branch itself.\n           *\n           * @returns {string}\n           */\n\n        }, {\n          key: 'getColour',\n          value: function getColour(specifiedColour) {\n            if (this.selected) {\n              return this.tree.selectedColour;\n            }\n\n            return specifiedColour || this.colour || this.tree.branchColour;\n          }\n          /**\n           * Create a newick representation of this branch.\n           *\n           * @returns {string}\n           */\n\n        }, {\n          key: 'getNwk',\n          value: function getNwk() {\n            var isRoot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            if (this.leaf) {\n              return this.label + ':' + this.branchLength;\n            }\n\n            var childNwks = this.children.map(function (child) {\n              return child.getNwk(false);\n            });\n            return '(' + childNwks.join(',') + '):' + this.branchLength + (isRoot ? ';' : '');\n          }\n          /**\n           * @returns {string}\n           */\n\n        }, {\n          key: 'getTextColour',\n          value: function getTextColour() {\n            if (this.selected) {\n              return this.tree.selectedColour;\n            }\n\n            if (this.isHighlighted) {\n              return this.tree.highlightColour;\n            }\n\n            if (this.tree.backColour && this.children.length) {\n              var childColours = this.getChildColours();\n\n              if (childColours.length === 1) {\n                return childColours[0];\n              }\n            }\n\n            return this.labelStyle.colour || this.colour || this.tree.branchColour;\n          }\n          /**\n           * Ensures the return value is always a string.\n           *\n           * @returns {string}\n           */\n\n        }, {\n          key: 'getLabel',\n          value: function getLabel() {\n            return this.label !== undefined && this.label !== null ? this.label : '';\n          }\n          /**\n           * @returns {number}\n           */\n\n        }, {\n          key: 'getTextSize',\n          value: function getTextSize() {\n            return this.labelStyle.textSize || this.tree.textSize;\n          }\n          /**\n           * @returns {string}\n           */\n\n        }, {\n          key: 'getFontString',\n          value: function getFontString() {\n            var font = this.labelStyle.font || this.tree.font;\n            return (this.labelStyle.format || '') + ' ' + this.getTextSize() + 'pt ' + font;\n          }\n          /**\n           * @returns {number} length of label in pixels\n           */\n\n        }, {\n          key: 'getLabelSize',\n          value: function getLabelSize() {\n            this.canvas.font = this.getFontString();\n            return this.canvas.measureText(this.getLabel()).width;\n          }\n          /**\n           * @returns {number}\n           */\n\n        }, {\n          key: 'getRadius',\n          value: function getRadius() {\n            var baseNodeSize = this.tree.baseNodeSize;\n\n            if (this.leaf) {\n              return baseNodeSize * this.radius;\n            }\n\n            return baseNodeSize / this.radius;\n          }\n          /**\n           * @returns {number}\n           */\n\n        }, {\n          key: 'getDiameter',\n          value: function getDiameter() {\n            return this.getRadius() * 2;\n          }\n          /**\n           * @returns {boolean}\n           */\n\n        }, {\n          key: 'hasLabelConnector',\n          value: function hasLabelConnector() {\n            if (!this.tree.alignLabels) {\n              return false;\n            }\n\n            return this.tree.labelAlign.getLabelOffset(this) > this.getDiameter();\n          }\n          /**\n           * Calculates label start position\n           * offset + aesthetic padding\n           *\n           * @return {number} x coordinate\n           */\n\n        }, {\n          key: 'getLabelStartX',\n          value: function getLabelStartX() {\n            var _getLeafStyle = this.getLeafStyle(),\n                lineWidth = _getLeafStyle.lineWidth;\n\n            var hasLabelConnector = this.hasLabelConnector();\n            var offset = this.getDiameter();\n\n            if (this.isHighlighted && !hasLabelConnector) {\n              offset += this.getHighlightSize() - this.getRadius();\n            }\n\n            return offset + Math.min(this.tree.labelPadding, this.tree.labelPadding / this.tree.zoom);\n          }\n          /**\n           * @returns {number}\n           */\n\n        }, {\n          key: 'getHighlightLineWidth',\n          value: function getHighlightLineWidth() {\n            return this.tree.highlightWidth / this.tree.zoom;\n          }\n          /**\n           * @returns {number}\n           */\n\n        }, {\n          key: 'getHighlightRadius',\n          value: function getHighlightRadius() {\n            var offset = this.getHighlightLineWidth() * this.tree.highlightSize;\n            offset += this.getLeafStyle().lineWidth / this.tree.highlightSize;\n            return this.leaf ? this.getRadius() + offset : offset * 0.666;\n          }\n          /**\n           * Combination of radius and line width\n           *\n           * @returns {number}\n           */\n\n        }, {\n          key: 'getHighlightSize',\n          value: function getHighlightSize() {\n            return this.getHighlightRadius() + this.getHighlightLineWidth();\n          }\n          /**\n           * Reverses the order of the children. Runs the prerenderer again.\n           *\n           * @method\n           */\n\n        }, {\n          key: 'rotate',\n          value: function rotate() {\n            var newChildren = [];\n\n            for (var i = this.children.length; i--;) {\n              newChildren.push(this.children[i]);\n            }\n\n            this.children = newChildren;\n            this.tree.extractNestedBranches();\n            this.tree.draw(true);\n          }\n          /**\n           * @returns {number} index of this branch in its parent's array.\n           */\n\n        }, {\n          key: 'getChildNo',\n          value: function getChildNo() {\n            return this.parent.children.indexOf(this);\n          }\n          /**\n           * @param {Object} options\n           * @param {string} options.colour\n           * @param {string} options.shape\n           * @param {number} options.size\n           * @param {Object} options.leafStyle See {@link Branch#leafStyle}\n           * @param {Object} options.labelStyle See {@link Branch#labelStyle}\n           */\n\n        }, {\n          key: 'setDisplay',\n          value: function setDisplay(_ref) {\n            var colour = _ref.colour,\n                shape = _ref.shape,\n                size = _ref.size,\n                leafStyle = _ref.leafStyle,\n                labelStyle = _ref.labelStyle;\n\n            if (colour) {\n              this.colour = colour;\n            }\n\n            if (shape) {\n              this.nodeShape = Shapes[shape] ? Shapes[shape] : shape;\n            }\n\n            if (size) {\n              this.radius = size;\n            }\n\n            if (leafStyle) {\n              this.leafStyle = leafStyle;\n            }\n\n            if (labelStyle) {\n              this.labelStyle = labelStyle;\n            }\n          }\n          /**\n           * @returns {number} the node radius plus label length if labels are shown\n           */\n\n        }, {\n          key: 'getTotalLength',\n          value: function getTotalLength() {\n            var length = this.getRadius();\n\n            if (this.tree.showLabels || this.tree.hoverLabel && this.isHighlighted) {\n              length += this.getLabelStartX() + this.getLabelSize();\n            }\n\n            return length;\n          }\n          /**\n           * @returns {Object} bounds\n           * @property {number} minx\n           * @property {number} miny\n           * @property {number} maxx\n           * @property {number} maxy\n           */\n\n        }, {\n          key: 'getBounds',\n          value: function getBounds() {\n            var tree = this.tree;\n            var x = tree.alignLabels ? tree.labelAlign.getX(this) : this.centerx;\n            var y = tree.alignLabels ? tree.labelAlign.getY(this) : this.centery;\n            var nodeSize = this.getRadius();\n            var totalLength = this.getTotalLength();\n            var minx = void 0;\n            var maxx = void 0;\n            var miny = void 0;\n            var maxy = void 0;\n\n            if (this.angle > Angles.QUARTER && this.angle < Angles.HALF + Angles.QUARTER) {\n              minx = x + totalLength * Math.cos(this.angle);\n              miny = y + totalLength * Math.sin(this.angle);\n              maxx = x - nodeSize;\n              maxy = y - nodeSize;\n            } else {\n              minx = x - nodeSize;\n              miny = y - nodeSize;\n              maxx = x + totalLength * Math.cos(this.angle);\n              maxy = y + totalLength * Math.sin(this.angle);\n            } // uses a caching object to reduce garbage\n\n\n            var step = tree.prerenderer.getStep(tree) / 2;\n            _bounds.minx = Math.min(minx, maxx, x - step);\n            _bounds.miny = Math.min(miny, maxy, y - step);\n            _bounds.maxx = Math.max(minx, maxx, x + step);\n            _bounds.maxy = Math.max(miny, maxy, y + step);\n            return _bounds;\n          }\n          /**\n           * Merges global and local styles together.\n           *\n           * @returns {Object}\n           * @see Branch#leafStyle\n           */\n\n        }, {\n          key: 'getLeafStyle',\n          value: function getLeafStyle() {\n            var _leafStyle2 = this.leafStyle,\n                strokeStyle = _leafStyle2.strokeStyle,\n                fillStyle = _leafStyle2.fillStyle;\n            var zoom = this.tree.zoom; // uses a caching object to reduce garbage\n\n            _leafStyle.strokeStyle = this.getColour(strokeStyle);\n            _leafStyle.fillStyle = this.getColour(fillStyle);\n            var lineWidth = typeof this.leafStyle.lineWidth !== 'undefined' ? this.leafStyle.lineWidth : this.tree.lineWidth;\n            _leafStyle.lineWidth = lineWidth / zoom;\n            return _leafStyle;\n          }\n        }, {\n          key: 'isHighlighted',\n\n          /**\n           * True if the branch is highlighted or hovered.\n           *\n           * @type boolean\n           */\n          get: function get() {\n            return this.highlighted || this.hovered;\n          }\n          /**\n           * The canvas {@link https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D drawing context} of the parent tree.\n           *\n           * @type CanvasRenderingContext2D\n           */\n\n        }, {\n          key: 'canvas',\n          get: function get() {\n            return this.tree.canvas;\n          }\n        }], [{\n          key: 'generateId',\n          value: function generateId() {\n            return 'pcn' + this.lastId++;\n          }\n        }]);\n\n        return Branch;\n      }();\n      /**\n       * Static counter for generated ids.\n       *\n       * @static\n       * @memberof Branch\n       * @type number\n       */\n\n\n      Branch.lastId = 0;\n      exports.default = Branch;\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _rectangular = __webpack_require__(9);\n\n      var _rectangular2 = _interopRequireDefault(_rectangular);\n\n      var _circular = __webpack_require__(14);\n\n      var _circular2 = _interopRequireDefault(_circular);\n\n      var _radial = __webpack_require__(17);\n\n      var _radial2 = _interopRequireDefault(_radial);\n\n      var _diagonal = __webpack_require__(20);\n\n      var _diagonal2 = _interopRequireDefault(_diagonal);\n\n      var _hierarchical = __webpack_require__(23);\n\n      var _hierarchical2 = _interopRequireDefault(_hierarchical);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      exports.default = {\n        rectangular: _rectangular2.default,\n        circular: _circular2.default,\n        radial: _radial2.default,\n        diagonal: _diagonal2.default,\n        hierarchical: _hierarchical2.default\n      };\n      /***/\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _BranchRenderer = __webpack_require__(10);\n\n      var _BranchRenderer2 = _interopRequireDefault(_BranchRenderer);\n\n      var _Prerenderer = __webpack_require__(11);\n\n      var _Prerenderer2 = _interopRequireDefault(_Prerenderer);\n\n      var _branchRenderer = __webpack_require__(12);\n\n      var _branchRenderer2 = _interopRequireDefault(_branchRenderer);\n\n      var _prerenderer = __webpack_require__(13);\n\n      var _prerenderer2 = _interopRequireDefault(_prerenderer);\n\n      var _constants = __webpack_require__(6);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var labelAlign = {\n        getX: function getX(node) {\n          return node.tree.farthestNodeFromRootX * node.tree.currentBranchScale;\n        },\n        getY: function getY(node) {\n          return node.centery;\n        },\n        getLabelOffset: function getLabelOffset(node) {\n          return node.tree.farthestNodeFromRootX * node.tree.currentBranchScale - node.centerx;\n        }\n      };\n      exports.default = {\n        branchRenderer: new _BranchRenderer2.default(_branchRenderer2.default),\n        prerenderer: new _Prerenderer2.default(_prerenderer2.default),\n        labelAlign: labelAlign,\n        branchScalingAxis: 'x',\n        getCollapsedMeasurements: function getCollapsedMeasurements(branch) {\n          return {\n            angle: _constants.Angles.QUARTER,\n            radius: branch.tree.step * branch.getNumberOfLeaves()\n          };\n        }\n      };\n      /***/\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * Draws a branch.\n       *\n       * @class\n       */\n\n\n      var BranchRenderer = function () {\n        /**\n         * @constructor\n         * @param {Object} options\n         * @param {function} options.draw\n         * @param {function} [options.prepareChild]\n         */\n        function BranchRenderer(options) {\n          _classCallCheck(this, BranchRenderer);\n\n          if (!options || !options.draw) {\n            throw new Error('`draw` function is required for branch renderers');\n          }\n\n          this.draw = options.draw;\n          this.prepareChild = options.prepareChild;\n        }\n        /**\n         * @param {Tree}\n         * @param {Branch}\n         * @param {boolean=} - if true, rendering skipped.\n         */\n\n\n        _createClass(BranchRenderer, [{\n          key: 'render',\n          value: function render(tree, branch, collapse) {\n            var i;\n            if (collapse || !branch) return;\n\n            if (branch.selected) {\n              branch.canvas.fillStyle = tree.selectedColour;\n            } else {\n              branch.canvas.fillStyle = branch.colour;\n            }\n\n            branch.canvas.strokeStyle = branch.getColour();\n            this.draw(tree, branch);\n\n            if (branch.pruned) {\n              return;\n            }\n\n            branch.drawNode();\n\n            for (i = 0; i < branch.children.length; i++) {\n              if (this.prepareChild) {\n                this.prepareChild(branch, branch.children[i]);\n              }\n\n              this.render(tree, branch.children[i], branch.collapsed || collapse);\n            }\n          }\n        }]);\n\n        return BranchRenderer;\n      }();\n\n      exports.default = BranchRenderer;\n      /***/\n    },\n    /* 11 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * Calculates the tree dimensions before the first draw.\n       *\n       * @class\n       */\n\n\n      var Prerenderer = function () {\n        /**\n         * @constructor\n         * @param {Object} options\n         * @param {function} options.getStep - should return the space between each branch.\n         * @param {function} options.calculate\n         */\n        function Prerenderer(options) {\n          _classCallCheck(this, Prerenderer);\n\n          this.getStep = options.getStep;\n          this.calculate = options.calculate;\n        }\n        /**\n         * @param {Tree}\n         */\n\n\n        _createClass(Prerenderer, [{\n          key: \"run\",\n          value: function run(tree) {\n            var step = this.getStep(tree);\n            tree.root.startx = 0;\n            tree.root.starty = 0;\n            tree.root.centerx = 0;\n            tree.root.centery = 0;\n            tree.farthestNodeFromRootX = 0;\n            tree.farthestNodeFromRootY = 0;\n            tree.currentBranchScale = 1;\n            tree.step = step;\n            this.calculate(tree, step);\n            tree.initialBranchScalar = tree.branchScalar; // Assign root startx and starty\n\n            tree.root.startx = tree.root.centerx;\n            tree.root.starty = tree.root.centery; // Set font size for tree and its branches\n\n            tree.setFontSize(step);\n            tree.setMaxLabelLength();\n          }\n        }]);\n\n        return Prerenderer;\n      }();\n\n      exports.default = Prerenderer;\n      /***/\n    },\n    /* 12 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = {\n        draw: function draw(tree, node) {\n          var branchLength = node.branchLength * tree.branchScalar;\n          node.angle = 0;\n\n          if (node.parent) {\n            node.centerx = node.startx + branchLength;\n          }\n\n          node.canvas.beginPath();\n          node.canvas.moveTo(node.startx, node.starty);\n          node.canvas.lineTo(node.startx, node.centery);\n          node.canvas.lineTo(node.centerx, node.centery);\n          node.canvas.stroke();\n          node.canvas.closePath();\n        },\n        prepareChild: function prepareChild(node, child) {\n          child.startx = node.centerx;\n          child.starty = node.centery;\n        }\n      };\n      /***/\n    },\n    /* 13 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = {\n        getStep: function getStep(tree) {\n          return tree.fillCanvas ? tree.canvas.canvas.height / tree.leaves.length : Math.max(tree.canvas.canvas.height / tree.leaves.length, tree.leaves[0].getDiameter() + tree.labelPadding);\n        },\n        calculate: function calculate(tree, ystep) {\n          // Calculate branchScalar based on canvas width and total branch length\n          // This is used to transform the X coordinate based on the canvas width and no. of branches\n          tree.branchScalar = tree.canvas.canvas.width / tree.maxBranchLength; // set initial positons of the branches\n\n          for (var i = 0; i < tree.leaves.length; i++) {\n            tree.leaves[i].angle = 0; // for rectangle\n            // Calculate and assign y coordinate for all the leaves\n\n            tree.leaves[i].centery = i > 0 ? tree.leaves[i - 1].centery + ystep : 0;\n            tree.leaves[i].centerx = tree.leaves[i].totalBranchLength * tree.branchScalar; // Assign x,y position of the farthest node from the root\n\n            if (tree.leaves[i].centerx > tree.farthestNodeFromRootX) {\n              tree.farthestNodeFromRootX = tree.leaves[i].centerx;\n            }\n\n            if (tree.leaves[i].centery > tree.farthestNodeFromRootY) {\n              tree.farthestNodeFromRootY = tree.leaves[i].centery;\n            } // Calculate and assign y coordinate for all the parent branches\n\n\n            for (var branch = tree.leaves[i]; branch.parent; branch = branch.parent) {\n              // Get all the children of a parent\n              var childrenArray = branch.parent.children; // Assign parent's y coordinate\n              // Logic: Total ystep of all the children of this parent / 2\n\n              branch.parent.centery = (childrenArray[0].centery + childrenArray[childrenArray.length - 1].centery) / 2;\n            }\n          }\n        }\n      };\n      /***/\n    },\n    /* 14 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _BranchRenderer = __webpack_require__(10);\n\n      var _BranchRenderer2 = _interopRequireDefault(_BranchRenderer);\n\n      var _Prerenderer = __webpack_require__(11);\n\n      var _Prerenderer2 = _interopRequireDefault(_Prerenderer);\n\n      var _branchRenderer = __webpack_require__(15);\n\n      var _branchRenderer2 = _interopRequireDefault(_branchRenderer);\n\n      var _prerenderer = __webpack_require__(16);\n\n      var _prerenderer2 = _interopRequireDefault(_prerenderer);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var labelAlign = {\n        getX: function getX(node) {\n          return node.centerx + node.labelOffsetX + node.getDiameter() * Math.cos(node.angle);\n        },\n        getY: function getY(node) {\n          return node.centery + node.labelOffsetY + node.getDiameter() * Math.sin(node.angle);\n        },\n        getLabelOffset: function getLabelOffset(node) {\n          return node.labelOffsetX / Math.cos(node.angle);\n        }\n      };\n      exports.default = {\n        branchRenderer: new _BranchRenderer2.default(_branchRenderer2.default),\n        prerenderer: new _Prerenderer2.default(_prerenderer2.default),\n        labelAlign: labelAlign,\n        getCollapsedMeasurements: function getCollapsedMeasurements(branch) {\n          var _branch$tree = branch.tree,\n              maxBranchLength = _branch$tree.maxBranchLength,\n              branchScalar = _branch$tree.branchScalar,\n              step = _branch$tree.step;\n          return {\n            angle: branch.getNumberOfLeaves() * step,\n            radius: (maxBranchLength - branch.totalBranchLength) * branchScalar\n          };\n        },\n        calculateFontSize: function calculateFontSize(ystep) {\n          return Math.min(ystep * 10 + 4, 40);\n        }\n      };\n      /***/\n    },\n    /* 15 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = {\n        draw: function draw(tree, node) {\n          var branchLength = node.totalBranchLength * tree.branchScalar;\n          node.canvas.beginPath();\n          node.canvas.moveTo(node.startx, node.starty);\n          node.canvas.lineTo(node.centerx, node.centery);\n          node.canvas.stroke();\n          node.canvas.closePath();\n          node.canvas.strokeStyle = node.getColour();\n\n          if (node.children.length > 1 && !node.collapsed) {\n            node.canvas.beginPath();\n            node.canvas.arc(0, 0, branchLength, node.minChildAngle, node.maxChildAngle, node.maxChildAngle < node.minChildAngle);\n            node.canvas.stroke();\n            node.canvas.closePath();\n          }\n        }\n      };\n      /***/\n    },\n    /* 16 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _utils = __webpack_require__(2);\n\n      var Angles = _utils.constants.Angles;\n      exports.default = {\n        getStep: function getStep(tree) {\n          return Angles.FULL / tree.leaves.length;\n        },\n        calculate: function calculate(tree, step) {\n          tree.branchScalar = Math.min(tree.canvas.canvas.width, tree.canvas.canvas.height) / tree.maxBranchLength; // work out radius of tree and the make branch scalar proportinal to the\n\n          var r = tree.leaves.length * tree.leaves[0].getDiameter() / Angles.FULL;\n\n          if (tree.branchScalar * tree.maxBranchLength > r) {\n            r = tree.branchScalar * tree.maxBranchLength;\n          } else {\n            tree.branchScalar = r / tree.maxBranchLength;\n          }\n\n          for (var i = 0; i < tree.leaves.length; i++) {\n            var node = tree.leaves[i];\n            node.angle = step * i;\n            node.startx = node.parent.totalBranchLength * tree.branchScalar * Math.cos(node.angle);\n            node.starty = node.parent.totalBranchLength * tree.branchScalar * Math.sin(node.angle);\n            node.centerx = node.totalBranchLength * tree.branchScalar * Math.cos(node.angle);\n            node.centery = node.totalBranchLength * tree.branchScalar * Math.sin(node.angle);\n            node.labelOffsetX = r * Math.cos(node.angle) - node.centerx;\n            node.labelOffsetY = r * Math.sin(node.angle) - node.centery;\n\n            for (; node.parent; node = node.parent) {\n              if (node.getChildNo() === 0) {\n                node.parent.angle = node.angle;\n                node.parent.minChildAngle = node.angle;\n              }\n\n              if (node.getChildNo() === node.parent.children.length - 1) {\n                node.parent.maxChildAngle = node.angle;\n                node.parent.angle = (node.parent.minChildAngle + node.parent.maxChildAngle) / 2;\n                node.parent.startx = (node.parent.totalBranchLength - node.parent.branchLength) * tree.branchScalar * Math.cos(node.parent.angle);\n                node.parent.starty = (node.parent.totalBranchLength - node.parent.branchLength) * tree.branchScalar * Math.sin(node.parent.angle);\n                node.parent.centerx = node.parent.totalBranchLength * tree.branchScalar * Math.cos(node.parent.angle);\n                node.parent.centery = node.parent.totalBranchLength * tree.branchScalar * Math.sin(node.parent.angle);\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      };\n      /***/\n    },\n    /* 17 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _BranchRenderer = __webpack_require__(10);\n\n      var _BranchRenderer2 = _interopRequireDefault(_BranchRenderer);\n\n      var _Prerenderer = __webpack_require__(11);\n\n      var _Prerenderer2 = _interopRequireDefault(_Prerenderer);\n\n      var _branchRenderer = __webpack_require__(18);\n\n      var _branchRenderer2 = _interopRequireDefault(_branchRenderer);\n\n      var _prerenderer = __webpack_require__(19);\n\n      var _prerenderer2 = _interopRequireDefault(_prerenderer);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      exports.default = {\n        branchRenderer: new _BranchRenderer2.default(_branchRenderer2.default),\n        prerenderer: new _Prerenderer2.default(_prerenderer2.default),\n        getCollapsedMeasurements: function getCollapsedMeasurements(branch) {\n          var _branch$tree = branch.tree,\n              maxBranchLength = _branch$tree.maxBranchLength,\n              branchScalar = _branch$tree.branchScalar,\n              step = _branch$tree.step;\n          return {\n            angle: branch.getNumberOfLeaves() * step,\n            radius: (maxBranchLength - branch.totalBranchLength) * branchScalar\n          };\n        },\n        calculateFontSize: function calculateFontSize(ystep) {\n          return Math.min(ystep * 50 + 5, 15);\n        }\n      };\n      /***/\n    },\n    /* 18 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = {\n        draw: function draw(tree, node) {\n          node.canvas.beginPath();\n          node.canvas.moveTo(node.startx, node.starty);\n          node.canvas.lineTo(node.centerx, node.centery);\n          node.canvas.stroke();\n          node.canvas.closePath();\n        }\n      };\n      /***/\n    },\n    /* 19 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _utils = __webpack_require__(2);\n\n      var Angles = _utils.constants.Angles;\n\n      function prerenderNodes(tree, node) {\n        if (node.parent) {\n          node.startx = node.parent.centerx;\n          node.starty = node.parent.centery;\n        } else {\n          node.startx = 0;\n          node.starty = 0;\n        }\n\n        node.centerx = node.startx + node.branchLength * tree.branchScalar * Math.cos(node.angle);\n        node.centery = node.starty + node.branchLength * tree.branchScalar * Math.sin(node.angle);\n\n        for (var i = 0; i < node.children.length; i++) {\n          prerenderNodes(tree, node.children[i]);\n        }\n      }\n\n      exports.default = {\n        getStep: function getStep(tree) {\n          return Angles.FULL / tree.leaves.length;\n        },\n        calculate: function calculate(tree, step) {\n          tree.branchScalar = Math.min(tree.canvas.canvas.width, tree.canvas.canvas.height) / tree.maxBranchLength;\n\n          for (var i = 0.0; i < tree.leaves.length; i += 1.0) {\n            tree.leaves[i].angle = step * i;\n            tree.leaves[i].centerx = tree.leaves[i].totalBranchLength * tree.branchScalar * Math.cos(tree.leaves[i].angle);\n            tree.leaves[i].centery = tree.leaves[i].totalBranchLength * tree.branchScalar * Math.sin(tree.leaves[i].angle);\n\n            for (var node = tree.leaves[i]; node.parent; node = node.parent) {\n              if (node.getChildNo() === 0) {\n                node.parent.angle = 0;\n              }\n\n              node.parent.angle += node.angle * node.getChildCount();\n\n              if (node.getChildNo() === node.parent.children.length - 1) {\n                node.parent.angle = node.parent.angle / node.parent.getChildCount();\n              } else {\n                break;\n              }\n            }\n          }\n\n          prerenderNodes(tree, tree.root);\n        }\n      };\n      /***/\n    },\n    /* 20 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _BranchRenderer = __webpack_require__(10);\n\n      var _BranchRenderer2 = _interopRequireDefault(_BranchRenderer);\n\n      var _Prerenderer = __webpack_require__(11);\n\n      var _Prerenderer2 = _interopRequireDefault(_Prerenderer);\n\n      var _branchRenderer = __webpack_require__(21);\n\n      var _branchRenderer2 = _interopRequireDefault(_branchRenderer);\n\n      var _prerenderer = __webpack_require__(22);\n\n      var _prerenderer2 = _interopRequireDefault(_prerenderer);\n\n      var _constants = __webpack_require__(6);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      exports.default = {\n        branchRenderer: new _BranchRenderer2.default(_branchRenderer2.default),\n        prerenderer: new _Prerenderer2.default(_prerenderer2.default),\n        calculateFontSize: function calculateFontSize(ystep) {\n          return Math.min(ystep / 2, 10);\n        },\n        getCollapsedMeasurements: function getCollapsedMeasurements(branch) {\n          return {\n            angle: _constants.Angles.QUARTER,\n            radius: branch.tree.step * branch.getNumberOfLeaves()\n          };\n        }\n      };\n      /***/\n    },\n    /* 21 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = {\n        draw: function draw(tree, node) {\n          node.angle = 0;\n          node.canvas.beginPath();\n          node.canvas.moveTo(node.startx, node.starty);\n          node.canvas.lineTo(node.centerx, node.centery);\n          node.canvas.stroke();\n          node.canvas.closePath();\n        },\n        prepareChild: function prepareChild(node, child) {\n          child.startx = node.centerx;\n          child.starty = node.centery;\n        }\n      };\n      /***/\n    },\n    /* 22 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _utils = __webpack_require__(2);\n\n      var Angles = _utils.constants.Angles;\n      exports.default = {\n        getStep: function getStep(tree) {\n          return Math.max(tree.canvas.canvas.height / tree.leaves.length, tree.leaves[0].getDiameter() + tree.labelPadding);\n        },\n        calculate: function calculate(tree, ystep) {\n          for (var i = 0; i < tree.leaves.length; i++) {\n            tree.leaves[i].centerx = 0;\n            tree.leaves[i].centery = i > 0 ? tree.leaves[i - 1].centery + ystep : 0;\n            tree.leaves[i].angle = 0;\n\n            for (var node = tree.leaves[i]; node.parent; node = node.parent) {\n              if (node.getChildNo() === node.parent.children.length - 1) {\n                node.parent.centery = node.parent.getChildYTotal() / node.parent.getChildCount(); // (node.parent.children.length - 1);\n\n                node.parent.centerx = node.parent.children[0].centerx + (node.parent.children[0].centery - node.parent.centery) * Math.tan(Angles.FORTYFIVE);\n\n                for (var j = 0; j < node.parent.children.length; j++) {\n                  node.parent.children[j].startx = node.parent.centerx;\n                  node.parent.children[j].starty = node.parent.centery;\n                }\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      };\n      /***/\n    },\n    /* 23 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _BranchRenderer = __webpack_require__(10);\n\n      var _BranchRenderer2 = _interopRequireDefault(_BranchRenderer);\n\n      var _Prerenderer = __webpack_require__(11);\n\n      var _Prerenderer2 = _interopRequireDefault(_Prerenderer);\n\n      var _branchRenderer = __webpack_require__(24);\n\n      var _branchRenderer2 = _interopRequireDefault(_branchRenderer);\n\n      var _prerenderer = __webpack_require__(25);\n\n      var _prerenderer2 = _interopRequireDefault(_prerenderer);\n\n      var _constants = __webpack_require__(6);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var labelAlign = {\n        getX: function getX(node) {\n          return node.centerx;\n        },\n        getY: function getY(node) {\n          return node.tree.farthestNodeFromRootY * node.tree.currentBranchScale;\n        },\n        getLabelOffset: function getLabelOffset(node) {\n          return node.tree.farthestNodeFromRootY * node.tree.currentBranchScale - node.centery;\n        }\n      };\n      exports.default = {\n        branchRenderer: new _BranchRenderer2.default(_branchRenderer2.default),\n        prerenderer: new _Prerenderer2.default(_prerenderer2.default),\n        labelAlign: labelAlign,\n        branchScalingAxis: 'y',\n        getCollapsedMeasurements: function getCollapsedMeasurements(branch) {\n          return {\n            angle: _constants.Angles.QUARTER,\n            radius: branch.tree.step * branch.getNumberOfLeaves()\n          };\n        }\n      };\n      /***/\n    },\n    /* 24 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = {\n        draw: function draw(tree, node) {\n          var branchLength = node.branchLength * tree.branchScalar;\n\n          if (node.parent) {\n            node.centery = node.starty + branchLength;\n          }\n\n          node.canvas.beginPath();\n\n          if (node !== node.tree.root) {\n            node.canvas.moveTo(node.startx, node.starty);\n            node.canvas.lineTo(node.centerx, node.starty);\n          }\n\n          node.canvas.lineTo(node.centerx, node.centery);\n          node.canvas.stroke();\n          node.canvas.closePath();\n        },\n        prepareChild: function prepareChild(node, child) {\n          child.startx = node.centerx;\n          child.starty = node.centery;\n        }\n      };\n      /***/\n    },\n    /* 25 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _utils = __webpack_require__(2);\n\n      var Angles = _utils.constants.Angles;\n      exports.default = {\n        getStep: function getStep(tree) {\n          return tree.fillCanvas ? tree.canvas.canvas.width / tree.leaves.length : Math.max(tree.canvas.canvas.width / tree.leaves.length, tree.leaves[0].getDiameter() + tree.labelPadding);\n        },\n        calculate: function calculate(tree, xstep) {\n          tree.branchScalar = tree.canvas.canvas.height / tree.maxBranchLength;\n\n          for (var i = 0; i < tree.leaves.length; i++) {\n            tree.leaves[i].angle = Angles.QUARTER;\n            tree.leaves[i].centerx = i > 0 ? tree.leaves[i - 1].centerx + xstep : 0;\n            tree.leaves[i].centery = tree.leaves[i].totalBranchLength * tree.branchScalar;\n\n            for (var node = tree.leaves[i]; node.parent; node = node.parent) {\n              if (node.getChildNo() === 0) {\n                node.parent.centerx = node.centerx;\n              }\n\n              if (node.getChildNo() === node.parent.children.length - 1) {\n                node.parent.angle = Angles.QUARTER;\n                node.parent.centerx = (node.parent.centerx + node.centerx) / 2;\n                node.parent.centery = node.parent.totalBranchLength * tree.branchScalar;\n\n                for (var j = 0; j < node.parent.children.length; j++) {\n                  node.parent.children[j].startx = node.parent.centerx;\n                  node.parent.children[j].starty = node.parent.centery;\n                }\n              } else {\n                break;\n              }\n            } // Assign x,y position of the farthest node from the root\n\n\n            if (tree.leaves[i].centerx > tree.farthestNodeFromRootX) {\n              tree.farthestNodeFromRootX = tree.leaves[i].centerx;\n            }\n\n            if (tree.leaves[i].centery > tree.farthestNodeFromRootY) {\n              tree.farthestNodeFromRootY = tree.leaves[i].centery;\n            }\n          }\n        }\n      };\n      /***/\n    },\n    /* 26 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _utils = __webpack_require__(2);\n\n      var Angles = _utils.constants.Angles;\n\n      function drawConnector(canvas, connectingOffset) {\n        canvas.beginPath();\n        canvas.moveTo(0, 0);\n        canvas.lineTo(connectingOffset, 0);\n        canvas.stroke();\n        canvas.closePath();\n      }\n\n      function commitPath(canvas, _ref) {\n        var lineWidth = _ref.lineWidth,\n            strokeStyle = _ref.strokeStyle,\n            fillStyle = _ref.fillStyle;\n        canvas.lineWidth = lineWidth;\n        canvas.strokeStyle = strokeStyle;\n        canvas.fillStyle = fillStyle;\n        canvas.fill();\n\n        if (lineWidth > 0 && strokeStyle !== fillStyle) {\n          canvas.stroke();\n        }\n      }\n\n      var lengthOfSquareSide = function lengthOfSquareSide(radius) {\n        return radius * Math.sqrt(2);\n      };\n      /**\n       * @function nodeRenderer\n       * @description A pure function to render a leaf.\n       *\n       * @param {CanvasRenderingContext2D} canvas - See {@link Tree#canvas}\n       * @param {number} radius - See {@link Branch#radius}\n       * @param {Object} style - See {@link Branch#leafStyle}\n       */\n\n\n      exports.default = {\n        circle: function circle(canvas, radius, style) {\n          // circle takes same area as square inside given radius\n          var scaledArea = Math.pow(lengthOfSquareSide(radius), 2);\n          var scaledRadius = Math.sqrt(scaledArea / Math.PI);\n          drawConnector(canvas, radius - scaledRadius);\n          canvas.beginPath();\n          canvas.arc(radius, 0, scaledRadius, 0, Angles.FULL, false);\n          canvas.closePath();\n          commitPath(canvas, style);\n        },\n        square: function square(canvas, radius, style) {\n          var lengthOfSide = lengthOfSquareSide(radius);\n          var startX = radius - lengthOfSide / 2;\n          drawConnector(canvas, startX);\n          canvas.beginPath();\n          canvas.moveTo(startX, 0);\n          canvas.lineTo(startX, lengthOfSide / 2);\n          canvas.lineTo(startX + lengthOfSide, lengthOfSide / 2);\n          canvas.lineTo(startX + lengthOfSide, -lengthOfSide / 2);\n          canvas.lineTo(startX, -lengthOfSide / 2);\n          canvas.lineTo(startX, 0);\n          canvas.closePath();\n          commitPath(canvas, style);\n        },\n        star: function star(canvas, radius, style) {\n          var cx = radius;\n          var cy = 0;\n          var spikes = 5;\n          var outerRadius = radius;\n          var innerRadius = outerRadius * 0.5;\n          var step = Math.PI / spikes;\n          drawConnector(canvas, outerRadius - innerRadius);\n          var rot = Math.PI / 2 * 3;\n          canvas.beginPath();\n          canvas.moveTo(cx, cy - outerRadius);\n\n          for (var i = 0; i < spikes; i++) {\n            var x = cx + Math.cos(rot) * outerRadius;\n            var y = cy + Math.sin(rot) * outerRadius;\n            canvas.lineTo(x, y);\n            rot += step;\n            x = cx + Math.cos(rot) * innerRadius;\n            y = cy + Math.sin(rot) * innerRadius;\n            canvas.lineTo(x, y);\n            rot += step;\n          }\n\n          canvas.lineTo(cx, cy - outerRadius);\n          canvas.closePath();\n          commitPath(canvas, style);\n        },\n        triangle: function triangle(canvas, radius, style) {\n          var lengthOfSide = 2 * radius * Math.cos(30 * Math.PI / 180);\n          var height = Math.sqrt(3) / 2 * lengthOfSide;\n          var midpoint = 1 / Math.sqrt(3) * (lengthOfSide / 2);\n          drawConnector(canvas, radius - midpoint);\n          canvas.beginPath();\n          canvas.moveTo(radius, midpoint);\n          canvas.lineTo(radius + lengthOfSide / 2, midpoint);\n          canvas.lineTo(radius, -(height - midpoint));\n          canvas.lineTo(radius - lengthOfSide / 2, midpoint);\n          canvas.lineTo(radius, midpoint);\n          canvas.closePath();\n          commitPath(canvas, style);\n        }\n      };\n      /***/\n    },\n    /* 27 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof2(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof2(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * Tooltip base class\n       *\n       * @class\n       */\n\n\n      var Tooltip = function () {\n        /**\n         * @constructor\n         * @param {Tree} tree instance\n         * @param {Object} [options]\n         * @param {string} [options.className=phylocanvas-tooltip]\n         * @param {HTMLElement} [options.element=document.createElement('div')]\n         * @param {number} [options.zIndex=2000]\n         * @param {HTMLElement} [options.parent=tree.containerElement]\n         */\n        function Tooltip(tree) {\n          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n              _ref$className = _ref.className,\n              className = _ref$className === undefined ? 'phylocanvas-tooltip' : _ref$className,\n              _ref$element = _ref.element,\n              element = _ref$element === undefined ? document.createElement('div') : _ref$element,\n              _ref$zIndex = _ref.zIndex,\n              zIndex = _ref$zIndex === undefined ? 2000 : _ref$zIndex,\n              _ref$parent = _ref.parent,\n              parent = _ref$parent === undefined ? tree.containerElement : _ref$parent;\n\n          _classCallCheck(this, Tooltip);\n\n          this.tree = tree;\n          this.element = element;\n          this.element.className = className;\n          this.element.style.display = 'none';\n          this.element.style.position = 'fixed';\n          this.element.style.zIndex = zIndex;\n          this.closed = true;\n          parent.appendChild(this.element);\n        }\n        /**\n         * @method\n         */\n\n\n        _createClass(Tooltip, [{\n          key: 'close',\n          value: function close() {\n            this.element.style.display = 'none';\n            this.closed = true;\n          }\n          /**\n           * @param {number} [x=100]\n           * @param {number} [y=100]\n           * @param {Branch} [node]\n           */\n\n        }, {\n          key: 'open',\n          value: function open() {\n            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n            var node = arguments[2];\n\n            while (this.element.hasChildNodes()) {\n              this.element.removeChild(this.element.firstChild);\n            }\n\n            this.createContent(node);\n            this.element.style.top = y + 'px';\n            this.element.style.left = x + 'px';\n            this.element.style.display = 'block';\n            this.closed = false;\n          }\n          /**\n           * @throws an error if not overridden by a subclass.\n           */\n\n        }, {\n          key: 'createContent',\n          value: function createContent() {\n            throw new Error('Not implemented');\n          }\n        }]);\n\n        return Tooltip;\n      }();\n\n      exports.default = Tooltip; // named export cannot have a doclet\n      // @extends not working well\n\n      var ChildNodesTooltip = exports.ChildNodesTooltip = function (_Tooltip) {\n        _inherits(ChildNodesTooltip, _Tooltip);\n        /**\n         * Tooltip displaying number of child nodes.\n         *\n         * @constructor\n         * @param {Tree} tree instance\n         * @param {Object} [options]\n         * @see Tooltip\n         */\n\n\n        function ChildNodesTooltip(tree, options) {\n          _classCallCheck(this, ChildNodesTooltip);\n\n          var _this = _possibleConstructorReturn(this, (ChildNodesTooltip.__proto__ || Object.getPrototypeOf(ChildNodesTooltip)).call(this, tree, options));\n\n          _this.element.style.background = 'rgba(97, 97, 97, 0.9)';\n          _this.element.style.color = '#fff';\n          _this.element.style.cursor = 'pointer';\n          _this.element.style.padding = '8px';\n          _this.element.style.marginTop = '16px';\n          _this.element.style.borderRadius = '2px';\n          _this.element.style.textAlign = 'center';\n          _this.element.style.fontFamily = _this.tree.font || 'sans-serif';\n          _this.element.style.fontSize = '10px';\n          _this.element.style.fontWeight = '500';\n          return _this;\n        }\n        /**\n         * Adds a text node containing the number of children.\n         * @override\n         */\n\n\n        _createClass(ChildNodesTooltip, [{\n          key: 'createContent',\n          value: function createContent(node) {\n            var textNode = document.createTextNode(node.getChildProperties('id').length);\n            this.element.appendChild(textNode);\n          }\n        }]);\n\n        return ChildNodesTooltip;\n      }(Tooltip);\n      /***/\n\n    },\n    /* 28 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _Parser = __webpack_require__(29);\n\n      var _Parser2 = _interopRequireDefault(_Parser);\n\n      var _newick = __webpack_require__(30);\n\n      var _newick2 = _interopRequireDefault(_newick);\n\n      var _nexus = __webpack_require__(31);\n\n      var _nexus2 = _interopRequireDefault(_nexus);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      exports.default = {\n        nexus: new _Parser2.default(_nexus2.default),\n        newick: new _Parser2.default(_newick2.default)\n      };\n      /***/\n    },\n    /* 29 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var Parser = function () {\n        function Parser(_ref) {\n          var format = _ref.format,\n              parseFn = _ref.parseFn,\n              fileExtension = _ref.fileExtension,\n              validator = _ref.validator;\n\n          _classCallCheck(this, Parser);\n\n          this.format = format;\n          this.parseFn = parseFn;\n          this.fileExtension = fileExtension;\n          this.validator = validator;\n        }\n\n        _createClass(Parser, [{\n          key: \"parse\",\n          value: function parse(_ref2, callback) {\n            var formatString = _ref2.formatString,\n                root = _ref2.root,\n                _ref2$options = _ref2.options,\n                options = _ref2$options === undefined ? {\n              validate: true\n            } : _ref2$options;\n\n            if (formatString.match(this.validator) || options.validate === false) {\n              return this.parseFn({\n                string: formatString,\n                root: root,\n                options: options\n              }, callback);\n            }\n\n            return callback(new Error(\"Format string does not validate as \\\"\" + this.format + \"\\\"\"));\n          }\n        }]);\n\n        return Parser;\n      }();\n\n      exports.default = Parser;\n      /***/\n    },\n    /* 30 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _Branch = __webpack_require__(7);\n\n      var _Branch2 = _interopRequireDefault(_Branch);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var format = 'newick';\n      var fileExtension = /\\.nwk$/;\n      var validator = /^[\\w\\W\\.\\*\\:(\\),-\\/]+;?\\s*$/gi;\n\n      function isTerminatingChar(terminatingChar) {\n        return this === terminatingChar;\n      }\n\n      var labelTerminatingChars = [':', ',', ')', ';'];\n\n      function parseLabel(string) {\n        var label = '';\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = string[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var char = _step.value;\n\n            if (labelTerminatingChars.some(isTerminatingChar.bind(char))) {\n              break;\n            }\n\n            label += char;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return label;\n      }\n\n      function parseAnnotations(label, branch) {\n        var segments = label.split('**');\n        var displayOptions = {};\n        branch.id = segments[0];\n        if (segments.length === 1) return;\n        segments = segments[1].split('*');\n\n        for (var b = 0; b < segments.length; b += 2) {\n          var value = segments[b + 1];\n\n          switch (segments[b]) {\n            case 'nsz':\n              displayOptions.size = window.parseInt(value);\n              break;\n\n            case 'nsh':\n              displayOptions.shape = value;\n              break;\n\n            case 'ncol':\n              displayOptions.colour = value;\n              break;\n\n            default:\n              break;\n          }\n        }\n\n        branch.setDisplay(displayOptions);\n      }\n\n      var nodeTerminatingChars = [')', ',', ';'];\n\n      function parseBranchLength(string) {\n        var nodeLength = '';\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = string[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var char = _step2.value;\n\n            if (nodeTerminatingChars.some(isTerminatingChar.bind(char))) {\n              break;\n            }\n\n            nodeLength += char;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return nodeLength;\n      }\n\n      function parseBranch(branch, string, index) {\n        var label = parseLabel(string.slice(index));\n        var postLabelIndex = index + label.length;\n        var branchLengthStr = '';\n\n        if (label.match(/\\*/)) {\n          parseAnnotations(label, branch);\n        }\n\n        if (string[postLabelIndex] === ':') {\n          branchLengthStr = parseBranchLength(string.slice(postLabelIndex + 1));\n          branch.branchLength = Math.max(parseFloat(branchLengthStr), 0);\n        } else {\n          branch.branchLength = 0;\n        }\n\n        if (label) {\n          branch.label = label;\n        }\n\n        branch.id = label || _Branch2.default.generateId();\n        return postLabelIndex + branchLengthStr.length;\n      }\n\n      function parseFn(_ref, callback) {\n        var string = _ref.string,\n            root = _ref.root;\n        var cleanString = string.replace(/(\\r|\\n)/g, '');\n        var currentNode = root;\n\n        for (var i = 0; i < cleanString.length; i++) {\n          var node = void 0;\n\n          switch (cleanString[i]) {\n            case '(':\n              // new Child\n              node = new _Branch2.default();\n              currentNode.addChild(node);\n              currentNode = node;\n              break;\n\n            case ')':\n              // return to parent\n              currentNode = currentNode.parent;\n              break;\n\n            case ',':\n              // new sibling\n              node = new _Branch2.default();\n              currentNode.parent.addChild(node);\n              currentNode = node;\n              break;\n\n            case ';':\n              break;\n\n            default:\n              try {\n                i = parseBranch(currentNode, cleanString, i);\n              } catch (e) {\n                return callback(e);\n              }\n\n              break;\n          }\n        }\n\n        return callback();\n      }\n\n      exports.default = {\n        format: format,\n        fileExtension: fileExtension,\n        validator: validator,\n        parseFn: parseFn\n      };\n      /***/\n    },\n    /* 31 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _newick = __webpack_require__(30);\n\n      var format = 'nexus';\n      var fileExtension = /\\.n(ex|xs)$/;\n      var validator = /^#NEXUS[\\s\\n;\\w\\W\\.\\*\\:(\\),-=\\[\\]\\/&]+$/i;\n\n      function parseFn(_ref, callback) {\n        var string = _ref.string,\n            root = _ref.root,\n            options = _ref.options;\n\n        if (!string.match(/BEGIN TREES/gi)) {\n          return callback(new Error('The nexus file does not contain a tree block'));\n        }\n\n        var name = options.name; // get everything between BEGIN TREES and next END;\n\n        var treeSection = string.match(/BEGIN TREES;[\\S\\s]+END;/i)[0].replace(/BEGIN TREES;\\n/i, '').replace(/END;/i, ''); // get translate section\n\n        var leafNameObject = {};\n        var translateSection = treeSection.match(/TRANSLATE[^;]+;/i);\n\n        if (translateSection && translateSection.length) {\n          translateSection = translateSection[0]; //remove translate section from tree section\n\n          treeSection = treeSection.replace(translateSection, ''); //parse translate section into kv pairs\n\n          translateSection = translateSection.replace(/translate|;/gi, '');\n          var tIntArr = translateSection.split(',');\n\n          for (var i = 0; i < tIntArr.length; i++) {\n            var ia = tIntArr[i].trim().replace('\\n', '').split(' ');\n\n            if (ia[0] && ia[1]) {\n              leafNameObject[ia[0].trim()] = ia[1].trim();\n            }\n          }\n        } // find each line starting with tree.\n\n\n        var tArr = treeSection.split('\\n');\n        var trees = {}; // id name is '' or does not exist, ask user to choose which tree.\n\n        for (var _i = 0; _i < tArr.length; _i++) {\n          if (tArr[_i].trim() === '') continue;\n\n          var s = tArr[_i].replace(/tree\\s/i, '');\n\n          if (!name) {\n            name = s.trim().match(/^\\w+/)[0];\n          }\n\n          trees[name] = s.trim().match(/[\\S]*$/)[0];\n        }\n\n        if (!trees[name]) {\n          return new Error('tree ' + name + ' does not exist in this NEXUS file');\n        }\n\n        (0, _newick.parseFn)({\n          string: trees[name].trim(),\n          root: root\n        }, function (error) {\n          if (error) {\n            return callback(error);\n          }\n\n          callback(); // translate in accordance with translate block\n\n          if (leafNameObject) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = Object.keys(leafNameObject)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var n = _step.value;\n                var branches = root.tree.branches;\n                var branch = branches[n];\n                delete branches[n];\n                branch.id = leafNameObject[n];\n                branches[branch.id] = branch;\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            root.tree.draw();\n          }\n        });\n      }\n\n      exports.default = {\n        parseFn: parseFn,\n        format: format,\n        fileExtension: fileExtension,\n        validator: validator\n      };\n      /***/\n    }\n    /******/\n    ])\n  );\n});\n\n;","map":null,"metadata":{},"sourceType":"script"}