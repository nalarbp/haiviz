{"ast":null,"code":"import { NEW_NODE_SIZE_MOVE, NEW_TEXT_SIZE_MOVE, NEW_TEXT_OFFSET_MOVE, NEW_RESIZE_SIGNAL_MOVE, IS_OVERLAPPING_LINE_SHOWN, IS_OVERLAPPING_LINE_SCALED, OVERLAPPING_LINE_SCALE_FACTOR, IS_SORTED_BY_SUFFIX, SUFFIX_SEPARATOR, IS_RESORT } from \"../utils/constants\";\nimport { initialState } from \"../reducers\";\n\nvar movementSettingsReducer = function movementSettingsReducer(prevState, action) {\n  switch (action.type) {\n    case NEW_NODE_SIZE_MOVE:\n      var newState_nodeSize = Object.assign({}, prevState);\n\n      if (action.payload && action.payload !== prevState.nodeSize) {\n        newState_nodeSize.nodeSize = action.payload;\n      }\n\n      return newState_nodeSize;\n    // if no change return same state with before\n\n    case NEW_TEXT_SIZE_MOVE:\n      var newState_textSize = Object.assign({}, prevState);\n\n      if (action.payload && action.payload !== prevState.textSize) {\n        newState_textSize.textSize = action.payload;\n      }\n\n      return newState_textSize;\n\n    case NEW_TEXT_OFFSET_MOVE:\n      var newState_textOffset = Object.assign({}, prevState);\n\n      if (action.payload && action.payload !== prevState.textOffset) {\n        newState_textOffset.textOffset = action.payload;\n      }\n\n      return newState_textOffset;\n\n    case NEW_RESIZE_SIGNAL_MOVE:\n      var newState_resizeSignal = Object.assign({}, prevState);\n\n      if (action.payload !== prevState.isUserStartResize) {\n        newState_resizeSignal.isUserStartResize = action.payload;\n      }\n\n      return newState_resizeSignal;\n\n    case IS_OVERLAPPING_LINE_SHOWN:\n      var newState_isOverlappingLineShown = Object.assign({}, prevState);\n\n      if (action.payload !== prevState.isOverlappingLineShown) {\n        newState_isOverlappingLineShown.isOverlappingLineShown = action.payload;\n      }\n\n      return newState_isOverlappingLineShown;\n\n    case IS_OVERLAPPING_LINE_SCALED:\n      var newState_isOverlappingLineScaled = Object.assign({}, prevState);\n\n      if (action.payload !== prevState.isOverlappingLineScaled) {\n        newState_isOverlappingLineScaled.isOverlappingLineScaled = action.payload;\n      }\n\n      return newState_isOverlappingLineScaled;\n\n    case IS_SORTED_BY_SUFFIX:\n      var newState_isSortedBySuffix = Object.assign({}, prevState);\n\n      if (action.payload !== prevState.isSortedBySuffix) {\n        newState_isSortedBySuffix.isSortedBySuffix = action.payload;\n      }\n\n      return newState_isSortedBySuffix;\n\n    case IS_RESORT:\n      var newState_isResort = Object.assign({}, prevState);\n\n      if (action.payload !== prevState.isResort) {\n        newState_isResort.isResort = action.payload;\n      }\n\n      return newState_isResort;\n\n    case OVERLAPPING_LINE_SCALE_FACTOR:\n      var newState_overlappingLineScaleFactor = Object.assign({}, prevState);\n\n      if (action.payload !== prevState.overlappingLineScaleFactor) {\n        newState_overlappingLineScaleFactor.overlappingLineScaleFactor = action.payload;\n      }\n\n      return newState_overlappingLineScaleFactor;\n\n    case SUFFIX_SEPARATOR:\n      var newState_suffixSeparator = Object.assign({}, prevState);\n\n      if (action.payload !== prevState.suffixSeparator) {\n        newState_suffixSeparator.suffixSeparator = action.payload;\n      }\n\n      return newState_suffixSeparator;\n\n    default:\n      if (prevState) {\n        return prevState;\n      } else {\n        return initialState.movementSettings;\n      }\n\n  }\n};\n\nexport default movementSettingsReducer;","map":{"version":3,"sources":["/Volumes/DATA/BUDI/APP_DEV/haiviz-v04/src/reducers/reducer-movementSettings.js"],"names":["NEW_NODE_SIZE_MOVE","NEW_TEXT_SIZE_MOVE","NEW_TEXT_OFFSET_MOVE","NEW_RESIZE_SIGNAL_MOVE","IS_OVERLAPPING_LINE_SHOWN","IS_OVERLAPPING_LINE_SCALED","OVERLAPPING_LINE_SCALE_FACTOR","IS_SORTED_BY_SUFFIX","SUFFIX_SEPARATOR","IS_RESORT","initialState","movementSettingsReducer","prevState","action","type","newState_nodeSize","Object","assign","payload","nodeSize","newState_textSize","textSize","newState_textOffset","textOffset","newState_resizeSignal","isUserStartResize","newState_isOverlappingLineShown","isOverlappingLineShown","newState_isOverlappingLineScaled","isOverlappingLineScaled","newState_isSortedBySuffix","isSortedBySuffix","newState_isResort","isResort","newState_overlappingLineScaleFactor","overlappingLineScaleFactor","newState_suffixSeparator","suffixSeparator","movementSettings"],"mappings":"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","sourcesContent":["import {\n  NEW_NODE_SIZE_MOVE,\n  NEW_TEXT_SIZE_MOVE,\n  NEW_TEXT_OFFSET_MOVE,\n  NEW_RESIZE_SIGNAL_MOVE,\n  IS_OVERLAPPING_LINE_SHOWN,\n  IS_OVERLAPPING_LINE_SCALED,\n  OVERLAPPING_LINE_SCALE_FACTOR,\n  IS_SORTED_BY_SUFFIX,\n  SUFFIX_SEPARATOR,\n  IS_RESORT,\n} from \"../utils/constants\";\nimport { initialState } from \"../reducers\";\n\nconst movementSettingsReducer = (prevState, action) => {\n  switch (action.type) {\n    case NEW_NODE_SIZE_MOVE:\n      let newState_nodeSize = Object.assign({}, prevState);\n      if (action.payload && action.payload !== prevState.nodeSize) {\n        newState_nodeSize.nodeSize = action.payload;\n      }\n      return newState_nodeSize; // if no change return same state with before\n\n    case NEW_TEXT_SIZE_MOVE:\n      let newState_textSize = Object.assign({}, prevState);\n      if (action.payload && action.payload !== prevState.textSize) {\n        newState_textSize.textSize = action.payload;\n      }\n      return newState_textSize;\n\n    case NEW_TEXT_OFFSET_MOVE:\n      let newState_textOffset = Object.assign({}, prevState);\n      if (action.payload && action.payload !== prevState.textOffset) {\n        newState_textOffset.textOffset = action.payload;\n      }\n      return newState_textOffset;\n\n    case NEW_RESIZE_SIGNAL_MOVE:\n      let newState_resizeSignal = Object.assign({}, prevState);\n      if (action.payload !== prevState.isUserStartResize) {\n        newState_resizeSignal.isUserStartResize = action.payload;\n      }\n      return newState_resizeSignal;\n\n    case IS_OVERLAPPING_LINE_SHOWN:\n      let newState_isOverlappingLineShown = Object.assign({}, prevState);\n      if (action.payload !== prevState.isOverlappingLineShown) {\n        newState_isOverlappingLineShown.isOverlappingLineShown = action.payload;\n      }\n      return newState_isOverlappingLineShown;\n\n    case IS_OVERLAPPING_LINE_SCALED:\n      let newState_isOverlappingLineScaled = Object.assign({}, prevState);\n      if (action.payload !== prevState.isOverlappingLineScaled) {\n        newState_isOverlappingLineScaled.isOverlappingLineScaled =\n          action.payload;\n      }\n      return newState_isOverlappingLineScaled;\n\n    case IS_SORTED_BY_SUFFIX:\n      let newState_isSortedBySuffix = Object.assign({}, prevState);\n      if (action.payload !== prevState.isSortedBySuffix) {\n        newState_isSortedBySuffix.isSortedBySuffix = action.payload;\n      }\n      return newState_isSortedBySuffix;\n\n    case IS_RESORT:\n      let newState_isResort = Object.assign({}, prevState);\n      if (action.payload !== prevState.isResort) {\n        newState_isResort.isResort = action.payload;\n      }\n      return newState_isResort;\n\n    case OVERLAPPING_LINE_SCALE_FACTOR:\n      let newState_overlappingLineScaleFactor = Object.assign({}, prevState);\n      if (action.payload !== prevState.overlappingLineScaleFactor) {\n        newState_overlappingLineScaleFactor.overlappingLineScaleFactor =\n          action.payload;\n      }\n      return newState_overlappingLineScaleFactor;\n\n    case SUFFIX_SEPARATOR:\n      let newState_suffixSeparator = Object.assign({}, prevState);\n      if (action.payload !== prevState.suffixSeparator) {\n        newState_suffixSeparator.suffixSeparator = action.payload;\n      }\n      return newState_suffixSeparator;\n\n    default:\n      if (prevState) {\n        return prevState;\n      } else {\n        return initialState.movementSettings;\n      }\n  }\n};\n\nexport default movementSettingsReducer;\n"]},"metadata":{},"sourceType":"module"}