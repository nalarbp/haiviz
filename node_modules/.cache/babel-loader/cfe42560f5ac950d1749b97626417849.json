{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { text, csv } from \"d3-fetch\";\nimport { hierarchy } from \"d3-hierarchy\";\nimport * as d3Chroma from \"d3-scale-chromatic\";\nimport * as constant from \"./constants\";\nimport { rollup } from \"d3-array\";\nimport { isoDateParser, filterUnique, colorOrdinalInterpolator, parseXML, parseTree //parseGraph,\n, parseMovement, getUserDefinedColor, parseDOTtoCytoscape, isIsolateOrHost } from \"./utils\";\n\nvar _ = require(\"lodash\"); // =========================== LOAD SHOWCASE DATA ============================\n\n\nexport function loadShowcaseData(datasetId, loadIsolateData, setColorScale, loadSimulatedMap, loadXML, loadTreeData, loadMovementData, loadTransgraphData, deactivateChartMulti) {\n  switch (datasetId) {\n    case \"showcase-data-1\":\n      loadShowcaseDataHandler(constant.SHOWCASE_1, loadIsolateData, setColorScale, loadSimulatedMap, loadXML, loadTreeData, loadMovementData, loadTransgraphData, deactivateChartMulti);\n      break;\n\n    case \"showcase-data-2\":\n      loadShowcaseDataHandler(constant.SHOWCASE_2, loadIsolateData, setColorScale, loadSimulatedMap, loadXML, loadTreeData, loadMovementData, loadTransgraphData, deactivateChartMulti);\n      break;\n\n    case \"showcase-data-3\":\n      loadShowcaseDataHandler(constant.SHOWCASE_3, loadIsolateData, setColorScale, loadSimulatedMap, loadXML, loadTreeData, loadMovementData, loadTransgraphData, deactivateChartMulti);\n      break;\n\n    default:\n  }\n}\nexport function loadShowcaseDataHandler(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9) {\n  return _loadShowcaseDataHandler.apply(this, arguments);\n}\n\nfunction _loadShowcaseDataHandler() {\n  _loadShowcaseDataHandler = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(fileURL, loadIsolateData, setColorScale, loadSimulatedMap, loadXML, loadTreeData, loadMovementData, loadTransgraphData, deactivateChartMulti) {\n    var activeChart, data_promise_raw, validHeaders, inputHeaders, isCompulsoryHeadersValid, isolate_name, duplicatedRecords, isolate_name_empty, isolate_date_invalid, data_promise, colHeaders, colHeaders_Map, isolateName_list, sourceName_list, species_list, location_list, sourceType_list, profile1_list, profile2_list, profile3_list, colorScale_bySpecies, colorScale_byLocation, colorScale_bySourceType, colorScale_byProfile1, colorScale_byProfile2, colorScale_byProfile3, colorbySpecies_Map, colorbyLocation_Map, colorbySourceType_Map, colorbyProfile1_Map, colorbyProfile2_Map, colorbyProfile3_Map, colorScale_init, locationRollup, childrenAccessorFn, hierarchyData, isolateData_Map, parseGraph;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            //deactivateChart\n            activeChart = {\n              summary: {\n                show: false\n              },\n              idxCol: {\n                show: false\n              },\n              simulatedMap: {\n                show: false\n              },\n              floorplan: {\n                show: false\n              },\n              bar: {\n                show: false\n              },\n              tree: {\n                show: false\n              },\n              transmission: {\n                show: false\n              },\n              gantt: {\n                show: false\n              },\n              treeGantt: {\n                show: false\n              },\n              table: {\n                show: false\n              }\n            };\n            deactivateChartMulti(activeChart);\n            _context2.next = 4;\n            return csv(fileURL.isolateData).then(function (result) {\n              return result;\n            });\n\n          case 4:\n            data_promise_raw = _context2.sent;\n            validHeaders = [\"isolate_name\", \"isolate_species\", \"isolate_colDate\", \"isolate_colLocation\", \"isolate_sourceType\", \"isolate_sourceName\", \"profile_1\", \"profile_2\", \"profile_3\"];\n            inputHeaders = Object.keys(data_promise_raw[0]);\n            isCompulsoryHeadersValid = true;\n            validHeaders.forEach(function (item) {\n              if (inputHeaders.indexOf(item) === -1) {\n                isCompulsoryHeadersValid = false;\n              }\n            });\n\n            if (isCompulsoryHeadersValid) {\n              _context2.next = 12;\n              break;\n            }\n\n            alert(\"Invalid file: missing compulsory header(s)\");\n            return _context2.abrupt(\"return\");\n\n          case 12:\n            // no duplicate in isolate name\n            isolate_name = _.countBy(data_promise_raw, \"isolate_name\");\n            duplicatedRecords = Object.keys(isolate_name).map(function (key) {\n              return {\n                name: key,\n                count: isolate_name[key]\n              };\n            }).filter(function (d) {\n              return d.count > 1;\n            });\n\n            if (!(duplicatedRecords.length > 0)) {\n              _context2.next = 17;\n              break;\n            }\n\n            alert(\"Invalid data: duplicate record in column isolate name:\" + \"\".concat(JSON.stringify(duplicatedRecords)));\n            return _context2.abrupt(\"return\");\n\n          case 17:\n            // no empty record in isolate_name\n            isolate_name_empty = isolate_name[\"\"] ? true : false;\n\n            if (!isolate_name_empty) {\n              _context2.next = 21;\n              break;\n            }\n\n            alert(\"Invalid data: column isolate_name contain empty record\");\n            return _context2.abrupt(\"return\");\n\n          case 21:\n            // no empty record or invalid format in collection date\n            isolate_date_invalid = false;\n            data_promise_raw.forEach(function (d) {\n              d.isolate_name = d.isolate_name.replace(/\\s*$/, \"\");\n              d.isolate_colDate = d.isolate_colDate.replace(/\\s*$/, \"\");\n              d.isolate_sourceType = d.isolate_sourceType.replace(/\\s*$/, \"\");\n              d.isolate_sourceName = d.isolate_sourceName.replace(/\\s*$/, \"\");\n              d.isolate_species = d.isolate_species.replace(/\\s*$/, \"\");\n              d.isolate_colLocation = d.isolate_colLocation.replace(/\\s*$/, \"\");\n\n              if (isoDateParser(d.isolate_colDate)) {\n                d[\"uid\"] = d.isolate_name;\n                d.isolate_colDate = isoDateParser(d.isolate_colDate);\n              } else {\n                isolate_date_invalid = true;\n              }\n            });\n            data_promise = data_promise_raw.map(function (d) {\n              return {\n                uid: d.uid,\n                isolate_name: d.isolate_name,\n                isolate_colDate: d.isolate_colDate,\n                isolate_sourceType: d.isolate_sourceType,\n                isolate_sourceName: d.isolate_sourceName,\n                isolate_species: d.isolate_species,\n                isolate_colLocation: d.isolate_colLocation,\n                profile_1: d.profile_1,\n                profile_2: d.profile_2,\n                profile_3: d.profile_3\n              };\n            });\n\n            if (!isolate_date_invalid) {\n              _context2.next = 27;\n              break;\n            }\n\n            alert(\"Invalid data: wrong date format in column collection date\");\n            return _context2.abrupt(\"return\");\n\n          case 27:\n            // Create initial color table =====================================\n            // check and extract user defined color in the metadata\n            colHeaders = [];\n            inputHeaders.forEach(function (header) {\n              if (header.split(\":\")[1] === \"color\") {\n                var headerColorObj = {\n                  headerName: header,\n                  isHeaderHasColor: true\n                };\n                colHeaders.push(headerColorObj);\n              }\n            });\n            colHeaders_Map = new Map();\n            colHeaders.forEach(function (d) {\n              colHeaders_Map.set(d.headerName, d);\n            });\n            isolateName_list = data_promise.map(function (d) {\n              return d.isolate_name;\n            }).filter(filterUnique);\n            sourceName_list = data_promise.map(function (d) {\n              return d.isolate_sourceName;\n            }).filter(filterUnique);\n            species_list = data_promise.map(function (d) {\n              return d.isolate_species;\n            }).filter(filterUnique);\n            location_list = data_promise.map(function (d) {\n              return d.isolate_colLocation;\n            }).filter(filterUnique);\n            sourceType_list = data_promise.map(function (d) {\n              return d.isolate_sourceType;\n            }).filter(filterUnique);\n            profile1_list = data_promise.map(function (d) {\n              return d.profile_1;\n            }).filter(filterUnique);\n            profile2_list = data_promise.map(function (d) {\n              return d.profile_2;\n            }).filter(filterUnique);\n            profile3_list = data_promise.map(function (d) {\n              return d.profile_3;\n            }).filter(filterUnique); // is predefined color for species true? if so extract the color (metadata, column name), if no generate initial color\n\n            colorScale_bySpecies = colHeaders_Map.get(\"isolate_species:color\") ? getUserDefinedColor(data_promise_raw, species_list, \"isolate_species\", \"isolate_species:color\") : colorOrdinalInterpolator(species_list, d3Chroma.interpolateRdYlBu);\n            colorScale_byLocation = colHeaders_Map.get(\"isolate_colLocation:color\") ? getUserDefinedColor(data_promise_raw, location_list, \"isolate_colLocation\", \"isolate_colLocation:color\") : colorOrdinalInterpolator(location_list, d3Chroma.interpolateSpectral);\n            colorScale_bySourceType = colHeaders_Map.get(\"isolate_sourceType:color\") ? getUserDefinedColor(data_promise_raw, sourceType_list, \"isolate_sourceType\", \"isolate_sourceType:color\") : colorOrdinalInterpolator(sourceType_list, d3Chroma.interpolateSpectral);\n            colorScale_byProfile1 = colHeaders_Map.get(\"profile_1:color\") ? getUserDefinedColor(data_promise_raw, profile1_list, \"profile_1\", \"profile_1:color\") : colorOrdinalInterpolator(profile1_list, d3Chroma.interpolateViridis);\n            colorScale_byProfile2 = colHeaders_Map.get(\"profile_2:color\") ? getUserDefinedColor(data_promise_raw, profile2_list, \"profile_2\", \"profile_2:color\") : colorOrdinalInterpolator(profile2_list, d3Chroma.interpolateViridis);\n            colorScale_byProfile3 = colHeaders_Map.get(\"profile_3:color\") ? getUserDefinedColor(data_promise_raw, profile1_list, \"profile_3\", \"profile_3:color\") : colorOrdinalInterpolator(profile3_list, d3Chroma.interpolateViridis);\n            colorbySpecies_Map = new Map();\n            species_list.forEach(function (d) {\n              colorbySpecies_Map.set(d, colorScale_bySpecies(d));\n            });\n            colorbyLocation_Map = new Map();\n            location_list.forEach(function (d) {\n              colorbyLocation_Map.set(d, colorScale_byLocation(d));\n            });\n            colorbySourceType_Map = new Map();\n            sourceType_list.forEach(function (d) {\n              colorbySourceType_Map.set(d, colorScale_bySourceType(d));\n            });\n            colorbyProfile1_Map = new Map();\n            profile1_list.forEach(function (d) {\n              colorbyProfile1_Map.set(d, colorScale_byProfile1(d));\n            });\n            colorbyProfile2_Map = new Map();\n            profile2_list.forEach(function (d) {\n              colorbyProfile2_Map.set(d, colorScale_byProfile2(d));\n            });\n            colorbyProfile3_Map = new Map();\n            profile3_list.forEach(function (d) {\n              colorbyProfile3_Map.set(d, colorScale_byProfile3(d));\n            });\n            colorScale_init = {\n              colorType: \"location\",\n              byLocation: colorbyLocation_Map,\n              bySpecies: colorbySpecies_Map,\n              bySourceType: colorbySourceType_Map,\n              byProfile1: colorbyProfile1_Map,\n              byProfile2: colorbyProfile2_Map,\n              byProfile3: colorbyProfile3_Map,\n              byLocation_ori: colorbyLocation_Map,\n              bySpecies_ori: colorbySpecies_Map,\n              bySourceType_ori: colorbySourceType_Map,\n              byProfile1_ori: colorbyProfile1_Map,\n              byProfile2_ori: colorbyProfile2_Map,\n              byProfile3_ori: colorbyProfile3_Map\n            }; // make simulated map ================================================########\n\n            locationRollup = rollup(data_promise, function (d) {\n              return d.length;\n            }, function (d) {\n              return d.isolate_colLocation;\n            });\n\n            childrenAccessorFn = function childrenAccessorFn(_ref) {\n              var _ref2 = _slicedToArray(_ref, 2),\n                  value = _ref2[1];\n\n              return value.size && Array.from(value);\n            };\n\n            hierarchyData = hierarchy([null, locationRollup], childrenAccessorFn).sum(function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 2),\n                  value = _ref4[1];\n\n              return value;\n            }).sort(function (a, b) {\n              return b.value - a.value;\n            }); // make validation for transmission graph\n            //=========================================================================\n\n            isolateData_Map = new Map();\n            data_promise.forEach(function (d) {\n              isolateData_Map.set(d.uid, d);\n            });\n            loadIsolateData(isolateData_Map);\n            loadSimulatedMap(hierarchyData);\n            setColorScale(colorScale_init); //xml\n\n            if (fileURL.xmlData) {\n              parseXML(fileURL.xmlData, loadXML);\n            } else {\n              loadXML(null);\n            } //tree\n\n\n            if (fileURL.treeData) {\n              parseTree(fileURL.treeData, loadTreeData);\n            } else {\n              loadTreeData(null);\n            } //trans\n\n\n            if (fileURL.transData) {\n              parseGraph = /*#__PURE__*/function () {\n                var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fileURL) {\n                  var graph_promise, graph, nodeLabels, graphData, graph_key, graphWithValidation;\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return text(fileURL).then(function (result) {\n                            return result;\n                          });\n\n                        case 2:\n                          graph_promise = _context.sent;\n                          //const graph = parseDOTtoJSON(graph_promise);\n                          graph = parseDOTtoCytoscape(graph_promise);\n                          nodeLabels = graph.nodeLabels;\n                          graphData = graph.data;\n\n                          if (graphData) {\n                            //add layout detection here\n                            graph_key = isIsolateOrHost(nodeLabels, isolateName_list, sourceName_list);\n                            graphWithValidation = {\n                              graphKey: graph_key,\n                              graphData: graphData\n                            };\n                            loadTransgraphData(graphWithValidation);\n                          }\n\n                        case 7:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function parseGraph(_x10) {\n                  return _ref5.apply(this, arguments);\n                };\n              }();\n\n              parseGraph(fileURL.transData);\n            } else {\n              loadTransgraphData(null);\n            } //movement\n\n\n            if (fileURL.movementData) {\n              parseMovement(fileURL.movementData, loadMovementData);\n            } else {\n              loadMovementData(null);\n            }\n\n          case 70:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadShowcaseDataHandler.apply(this, arguments);\n}","map":{"version":3,"sources":["/Volumes/DATA/BUDI/APP_DEV/haiviz-v04/src/utils/loadShowcaseData.js"],"names":["text","csv","hierarchy","d3Chroma","constant","rollup","isoDateParser","filterUnique","colorOrdinalInterpolator","parseXML","parseTree","parseMovement","getUserDefinedColor","parseDOTtoCytoscape","isIsolateOrHost","_","require","loadShowcaseData","datasetId","loadIsolateData","setColorScale","loadSimulatedMap","loadXML","loadTreeData","loadMovementData","loadTransgraphData","deactivateChartMulti","loadShowcaseDataHandler","SHOWCASE_1","SHOWCASE_2","SHOWCASE_3","fileURL","activeChart","summary","show","idxCol","simulatedMap","floorplan","bar","tree","transmission","gantt","treeGantt","table","isolateData","then","result","data_promise_raw","validHeaders","inputHeaders","Object","keys","isCompulsoryHeadersValid","forEach","item","indexOf","alert","isolate_name","countBy","duplicatedRecords","map","key","name","count","filter","d","length","JSON","stringify","isolate_name_empty","isolate_date_invalid","replace","isolate_colDate","isolate_sourceType","isolate_sourceName","isolate_species","isolate_colLocation","data_promise","uid","profile_1","profile_2","profile_3","colHeaders","header","split","headerColorObj","headerName","isHeaderHasColor","push","colHeaders_Map","Map","set","isolateName_list","sourceName_list","species_list","location_list","sourceType_list","profile1_list","profile2_list","profile3_list","colorScale_bySpecies","get","interpolateRdYlBu","colorScale_byLocation","interpolateSpectral","colorScale_bySourceType","colorScale_byProfile1","interpolateViridis","colorScale_byProfile2","colorScale_byProfile3","colorbySpecies_Map","colorbyLocation_Map","colorbySourceType_Map","colorbyProfile1_Map","colorbyProfile2_Map","colorbyProfile3_Map","colorScale_init","colorType","byLocation","bySpecies","bySourceType","byProfile1","byProfile2","byProfile3","byLocation_ori","bySpecies_ori","bySourceType_ori","byProfile1_ori","byProfile2_ori","byProfile3_ori","locationRollup","childrenAccessorFn","value","size","Array","from","hierarchyData","sum","sort","a","b","isolateData_Map","xmlData","treeData","transData","parseGraph","graph_promise","graph","nodeLabels","graphData","data","graph_key","graphWithValidation","graphKey","movementData"],"mappings":"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","sourcesContent":["import { text, csv } from \"d3-fetch\";\nimport { hierarchy } from \"d3-hierarchy\";\nimport * as d3Chroma from \"d3-scale-chromatic\";\nimport * as constant from \"./constants\";\nimport { rollup } from \"d3-array\";\nimport {\n  isoDateParser,\n  filterUnique,\n  colorOrdinalInterpolator,\n  parseXML,\n  parseTree,\n  //parseGraph,\n  parseMovement,\n  getUserDefinedColor,\n  parseDOTtoCytoscape,\n  isIsolateOrHost,\n} from \"./utils\";\nconst _ = require(\"lodash\");\n\n// =========================== LOAD SHOWCASE DATA ============================\nexport function loadShowcaseData(\n  datasetId,\n  loadIsolateData,\n  setColorScale,\n  loadSimulatedMap,\n  loadXML,\n  loadTreeData,\n  loadMovementData,\n  loadTransgraphData,\n  deactivateChartMulti\n) {\n  switch (datasetId) {\n    case \"showcase-data-1\":\n      loadShowcaseDataHandler(\n        constant.SHOWCASE_1,\n        loadIsolateData,\n        setColorScale,\n        loadSimulatedMap,\n        loadXML,\n        loadTreeData,\n        loadMovementData,\n        loadTransgraphData,\n        deactivateChartMulti\n      );\n      break;\n    case \"showcase-data-2\":\n      loadShowcaseDataHandler(\n        constant.SHOWCASE_2,\n        loadIsolateData,\n        setColorScale,\n        loadSimulatedMap,\n        loadXML,\n        loadTreeData,\n        loadMovementData,\n        loadTransgraphData,\n        deactivateChartMulti\n      );\n      break;\n    case \"showcase-data-3\":\n      loadShowcaseDataHandler(\n        constant.SHOWCASE_3,\n        loadIsolateData,\n        setColorScale,\n        loadSimulatedMap,\n        loadXML,\n        loadTreeData,\n        loadMovementData,\n        loadTransgraphData,\n        deactivateChartMulti\n      );\n      break;\n    default:\n  }\n}\n\nexport async function loadShowcaseDataHandler(\n  fileURL,\n  loadIsolateData,\n  setColorScale,\n  loadSimulatedMap,\n  loadXML,\n  loadTreeData,\n  loadMovementData,\n  loadTransgraphData,\n  deactivateChartMulti\n) {\n  //deactivateChart\n  let activeChart = {\n    summary: { show: false },\n    idxCol: { show: false },\n    simulatedMap: { show: false },\n    floorplan: { show: false },\n    bar: { show: false },\n    tree: { show: false },\n    transmission: { show: false },\n    gantt: { show: false },\n    treeGantt: { show: false },\n    table: { show: false },\n  };\n  deactivateChartMulti(activeChart);\n  let data_promise_raw = await csv(fileURL.isolateData).then(function(result) {\n    return result;\n  });\n  const validHeaders = [\n    \"isolate_name\",\n    \"isolate_species\",\n    \"isolate_colDate\",\n    \"isolate_colLocation\",\n    \"isolate_sourceType\",\n    \"isolate_sourceName\",\n    \"profile_1\",\n    \"profile_2\",\n    \"profile_3\",\n  ];\n  const inputHeaders = Object.keys(data_promise_raw[0]);\n  let isCompulsoryHeadersValid = true;\n  validHeaders.forEach((item) => {\n    if (inputHeaders.indexOf(item) === -1) {\n      isCompulsoryHeadersValid = false;\n    }\n  });\n  if (!isCompulsoryHeadersValid) {\n    alert(\"Invalid file: missing compulsory header(s)\");\n    return;\n  }\n  // no duplicate in isolate name\n  const isolate_name = _.countBy(data_promise_raw, \"isolate_name\");\n  const duplicatedRecords = Object.keys(isolate_name)\n    .map((key) => {\n      return { name: key, count: isolate_name[key] };\n    })\n    .filter((d) => d.count > 1);\n  if (duplicatedRecords.length > 0) {\n    alert(\n      \"Invalid data: duplicate record in column isolate name:\" +\n        `${JSON.stringify(duplicatedRecords)}`\n    );\n    return;\n  }\n  // no empty record in isolate_name\n  const isolate_name_empty = isolate_name[\"\"] ? true : false;\n  if (isolate_name_empty) {\n    alert(\"Invalid data: column isolate_name contain empty record\");\n    return;\n  }\n  // no empty record or invalid format in collection date\n  let isolate_date_invalid = false;\n  data_promise_raw.forEach(function(d) {\n    d.isolate_name = d.isolate_name.replace(/\\s*$/, \"\");\n    d.isolate_colDate = d.isolate_colDate.replace(/\\s*$/, \"\");\n    d.isolate_sourceType = d.isolate_sourceType.replace(/\\s*$/, \"\");\n    d.isolate_sourceName = d.isolate_sourceName.replace(/\\s*$/, \"\");\n    d.isolate_species = d.isolate_species.replace(/\\s*$/, \"\");\n    d.isolate_colLocation = d.isolate_colLocation.replace(/\\s*$/, \"\");\n    if (isoDateParser(d.isolate_colDate)) {\n      d[\"uid\"] = d.isolate_name;\n      d.isolate_colDate = isoDateParser(d.isolate_colDate);\n    } else {\n      isolate_date_invalid = true;\n    }\n  });\n\n  let data_promise = data_promise_raw.map((d) => {\n    return {\n      uid: d.uid,\n      isolate_name: d.isolate_name,\n      isolate_colDate: d.isolate_colDate,\n      isolate_sourceType: d.isolate_sourceType,\n      isolate_sourceName: d.isolate_sourceName,\n      isolate_species: d.isolate_species,\n      isolate_colLocation: d.isolate_colLocation,\n      profile_1: d.profile_1,\n      profile_2: d.profile_2,\n      profile_3: d.profile_3,\n    };\n  });\n  if (isolate_date_invalid) {\n    alert(\"Invalid data: wrong date format in column collection date\");\n    return;\n  }\n  // Create initial color table =====================================\n  // check and extract user defined color in the metadata\n  let colHeaders = [];\n  inputHeaders.forEach((header) => {\n    if (header.split(\":\")[1] === \"color\") {\n      let headerColorObj = {\n        headerName: header,\n        isHeaderHasColor: true,\n      };\n      colHeaders.push(headerColorObj);\n    }\n  });\n  let colHeaders_Map = new Map();\n  colHeaders.forEach((d) => {\n    colHeaders_Map.set(d.headerName, d);\n  });\n  let isolateName_list = data_promise\n    .map((d) => {\n      return d.isolate_name;\n    })\n    .filter(filterUnique);\n  let sourceName_list = data_promise\n    .map((d) => {\n      return d.isolate_sourceName;\n    })\n    .filter(filterUnique);\n  let species_list = data_promise\n    .map((d) => {\n      return d.isolate_species;\n    })\n    .filter(filterUnique);\n  let location_list = data_promise\n    .map((d) => {\n      return d.isolate_colLocation;\n    })\n    .filter(filterUnique);\n  let sourceType_list = data_promise\n    .map((d) => {\n      return d.isolate_sourceType;\n    })\n    .filter(filterUnique);\n  let profile1_list = data_promise\n    .map((d) => {\n      return d.profile_1;\n    })\n    .filter(filterUnique);\n  let profile2_list = data_promise\n    .map((d) => {\n      return d.profile_2;\n    })\n    .filter(filterUnique);\n  let profile3_list = data_promise\n    .map((d) => {\n      return d.profile_3;\n    })\n    .filter(filterUnique);\n\n  // is predefined color for species true? if so extract the color (metadata, column name), if no generate initial color\n  const colorScale_bySpecies = colHeaders_Map.get(\"isolate_species:color\")\n    ? getUserDefinedColor(\n        data_promise_raw,\n        species_list,\n        \"isolate_species\",\n        \"isolate_species:color\"\n      )\n    : colorOrdinalInterpolator(species_list, d3Chroma.interpolateRdYlBu);\n\n  const colorScale_byLocation = colHeaders_Map.get(\"isolate_colLocation:color\")\n    ? getUserDefinedColor(\n        data_promise_raw,\n        location_list,\n        \"isolate_colLocation\",\n        \"isolate_colLocation:color\"\n      )\n    : colorOrdinalInterpolator(location_list, d3Chroma.interpolateSpectral);\n\n  const colorScale_bySourceType = colHeaders_Map.get(\"isolate_sourceType:color\")\n    ? getUserDefinedColor(\n        data_promise_raw,\n        sourceType_list,\n        \"isolate_sourceType\",\n        \"isolate_sourceType:color\"\n      )\n    : colorOrdinalInterpolator(sourceType_list, d3Chroma.interpolateSpectral);\n\n  const colorScale_byProfile1 = colHeaders_Map.get(\"profile_1:color\")\n    ? getUserDefinedColor(\n        data_promise_raw,\n        profile1_list,\n        \"profile_1\",\n        \"profile_1:color\"\n      )\n    : colorOrdinalInterpolator(profile1_list, d3Chroma.interpolateViridis);\n\n  const colorScale_byProfile2 = colHeaders_Map.get(\"profile_2:color\")\n    ? getUserDefinedColor(\n        data_promise_raw,\n        profile2_list,\n        \"profile_2\",\n        \"profile_2:color\"\n      )\n    : colorOrdinalInterpolator(profile2_list, d3Chroma.interpolateViridis);\n\n  const colorScale_byProfile3 = colHeaders_Map.get(\"profile_3:color\")\n    ? getUserDefinedColor(\n        data_promise_raw,\n        profile1_list,\n        \"profile_3\",\n        \"profile_3:color\"\n      )\n    : colorOrdinalInterpolator(profile3_list, d3Chroma.interpolateViridis);\n\n  let colorbySpecies_Map = new Map();\n  species_list.forEach((d) => {\n    colorbySpecies_Map.set(d, colorScale_bySpecies(d));\n  });\n  let colorbyLocation_Map = new Map();\n  location_list.forEach((d) => {\n    colorbyLocation_Map.set(d, colorScale_byLocation(d));\n  });\n  let colorbySourceType_Map = new Map();\n  sourceType_list.forEach((d) => {\n    colorbySourceType_Map.set(d, colorScale_bySourceType(d));\n  });\n  let colorbyProfile1_Map = new Map();\n  profile1_list.forEach((d) => {\n    colorbyProfile1_Map.set(d, colorScale_byProfile1(d));\n  });\n  let colorbyProfile2_Map = new Map();\n  profile2_list.forEach((d) => {\n    colorbyProfile2_Map.set(d, colorScale_byProfile2(d));\n  });\n  let colorbyProfile3_Map = new Map();\n  profile3_list.forEach((d) => {\n    colorbyProfile3_Map.set(d, colorScale_byProfile3(d));\n  });\n  const colorScale_init = {\n    colorType: \"location\",\n    byLocation: colorbyLocation_Map,\n    bySpecies: colorbySpecies_Map,\n    bySourceType: colorbySourceType_Map,\n    byProfile1: colorbyProfile1_Map,\n    byProfile2: colorbyProfile2_Map,\n    byProfile3: colorbyProfile3_Map,\n    byLocation_ori: colorbyLocation_Map,\n    bySpecies_ori: colorbySpecies_Map,\n    bySourceType_ori: colorbySourceType_Map,\n    byProfile1_ori: colorbyProfile1_Map,\n    byProfile2_ori: colorbyProfile2_Map,\n    byProfile3_ori: colorbyProfile3_Map,\n  };\n  // make simulated map ================================================########\n  const locationRollup = rollup(\n    data_promise,\n    (d) => d.length,\n    (d) => d.isolate_colLocation\n  );\n  const childrenAccessorFn = ([, value]) => {\n    return value.size && Array.from(value);\n  };\n  const hierarchyData = hierarchy([null, locationRollup], childrenAccessorFn)\n    .sum(([, value]) => value)\n    .sort((a, b) => b.value - a.value);\n\n  // make validation for transmission graph\n\n  //=========================================================================\n  let isolateData_Map = new Map();\n  data_promise.forEach((d) => {\n    isolateData_Map.set(d.uid, d);\n  });\n\n  loadIsolateData(isolateData_Map);\n  loadSimulatedMap(hierarchyData);\n  setColorScale(colorScale_init);\n\n  //xml\n  if (fileURL.xmlData) {\n    parseXML(fileURL.xmlData, loadXML);\n  } else {\n    loadXML(null);\n  }\n  //tree\n  if (fileURL.treeData) {\n    parseTree(fileURL.treeData, loadTreeData);\n  } else {\n    loadTreeData(null);\n  }\n  //trans\n  if (fileURL.transData) {\n    async function parseGraph(fileURL) {\n      let graph_promise = await text(fileURL).then(function(result) {\n        return result;\n      });\n      //const graph = parseDOTtoJSON(graph_promise);\n      const graph = parseDOTtoCytoscape(graph_promise);\n      const nodeLabels = graph.nodeLabels;\n      const graphData = graph.data;\n      if (graphData) {\n        //add layout detection here\n\n        let graph_key = isIsolateOrHost(\n          nodeLabels,\n          isolateName_list,\n          sourceName_list\n        );\n        let graphWithValidation = { graphKey: graph_key, graphData: graphData };\n        loadTransgraphData(graphWithValidation);\n      }\n    }\n    parseGraph(fileURL.transData);\n  } else {\n    loadTransgraphData(null);\n  }\n  //movement\n  if (fileURL.movementData) {\n    parseMovement(fileURL.movementData, loadMovementData);\n  } else {\n    loadMovementData(null);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}